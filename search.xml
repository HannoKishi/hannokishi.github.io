<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Libgo协程库</title>
    <url>/2022/01/19/Libgo%E5%8D%8F%E7%A8%8B%E5%BA%93/</url>
    <content><![CDATA[<hr>
<p>libgo有以下特点：<br>1.提供golang一般功能强大协程，基于corontine编写代码，可以以同步的方式编写简单的代码，同时获得异步的性能<br>2.支持海量协程, 创建100万个协程只需使用2GB物理内存<br>3.允许用户自由控制协程调度点，随时随地变更调度线程数<br>4.支持多线程调度协程，极易编写并行代码，高效的并行调度算法，可以有效利用多个CPU核心<br>5.可以让链接进程序的同步的第三方库变为异步调用，大大提升其性能。再也不用担心某些DB官方不提供异步driver了，比如hiredis、mysqlclient这种客户端驱动可以直接使用，并且可以得到不输于异步driver的性能<br>6.动态链接和静态链接全都支持，便于使用C++11的用户静态链接生成可执行文件并部署至低版本的linux系统上<br>7.提供协程锁(co_mutex), 定时器, channel等特性, 帮助用户更加容易地编写程序.<br>8.网络性能强劲，超越boost.asio异步模型；尤其在处理小包和多线程并行方面非常强大。</p>
<span id="more"></span>
<!-- toc -->

<p>[toc]</p>
<p><a href="https://github.com/yyzybb537/libgo/tree/master">参考教程1</a><br><a href="https://gitee.com/lwj8507/libgo">参考教程2</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/yyzybb537/libgo.git</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>这里我遇到了一个编译错误:大概意思是 atomic类型的拷贝构造被删除了<br>手动给 VntValueType添加一个默认构造函数解决</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>静态链接<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -std=c++11 sample1_go.cpp -llibgo -static -static-libgcc -static-libstdc++ -ldl -lpthread -lc</span><br><span class="line"></span><br><span class="line">g++ -static -static-libstdc++ -static-libgcc -lc -llibgo sample1_go.cpp -lpthread -std=c++11</span><br><span class="line"></span><br><span class="line">g++ -std=c++11 test.cpp -llibgo -Wl,--whole-archive -lstatic_hook -lc -lpthread -Wl,--no-whole-archive [-lother_libs] -static</span><br></pre></td></tr></table></figure></li>
<li> 动态链接<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -std=c++11 sample1_go.cpp -llibgo -ldl -pthread -std=c++11</span><br></pre></td></tr></table></figure></li>
<li>检查是否是静态链接<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ldd a.out </span><br><span class="line">not a dynamic executable</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h2><h3 id="协程与调度器"><a href="#协程与调度器" class="headerlink" title="协程与调度器"></a>协程与调度器</h3><p>使用关键字go创建协程, go后面可以使用:</p>
<ol>
<li>void(*)()函数指针, 比如:foo.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">go foo;</span><br></pre></td></tr></table></figure></li>
<li>也可以使用无参数的lambda, std::bind对象, function对象,<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">go []&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lambda\n&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>以及一切可以无参调用的仿函数对象<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">fn</span><span class="params">(std::bind(&amp;A::fB, A()))</span></span>;</span><br><span class="line">go fn;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>也可以使用go_stack创建指定栈大小的协程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//   创建拥有10MB大栈的协程</span><br><span class="line">go co_stack(10 * 1024 * 1024) []&#123;</span><br><span class="line">	printf(&quot;large stack\n&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：协程创建以后不会立即执行，而是暂存至可执行列表中，等待调度器调度。<code>co_sched</code>是默认的协程调度器，用户也可以使用自创建的协程调度器。当仅使用一个线程进行协程调度时, 协程地执行会严格地遵循其创建顺序.</p>
</li>
<li><p>仅使用主线程调度协程.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co_sched.<span class="built_in">Start</span>();</span><br></pre></td></tr></table></figure></li>
<li><p>以下代码可以使用等同于cpu核心数的线程调度协程.(包括主线程)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co_sched.<span class="built_in">Start</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>以下代码允许调度器自由扩展线程数，上限为1024.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 当有线程被协程阻塞时, 调度器会启动一个新的线程, 以此保障</span></span><br><span class="line"> <span class="comment">// 可用线程数总是等于Start的第一个参数(0表示cpu核心数).</span></span><br><span class="line">co_sched.<span class="built_in">Start</span>(<span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>另起一个线程跑调度器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不想让调度器卡住主线程, 可以使用以下方式:</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]&#123; co_sched.Start(); &#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">co_sleep</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义的调度器"><a href="#自定义的调度器" class="headerlink" title="自定义的调度器"></a>自定义的调度器</h3><ul>
<li>创建一个调度器<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co::Scheduler* sched = co::Scheduler::<span class="built_in">Create</span>();</span><br></pre></td></tr></table></figure></li>
<li> 启动新的调度器<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([sched]&#123; sched-&gt;Start(<span class="number">4</span>); &#125;)</span></span>;</span><br><span class="line">t2.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure></li>
<li>指定调度器上创建协程<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">go <span class="title">co_scheduler</span><span class="params">(sched)</span> []</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;run in my scheduler.\n&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="协程的主动切换"><a href="#协程的主动切换" class="headerlink" title="协程的主动切换"></a>协程的主动切换</h2><ul>
<li>co_yield关键字<br>可以主动让出调度器执行权限,让调度器有机会去执行其他协程,并将当前协程移动到可执行协程列表的尾部。</li>
<li>co_sched.Stop();<br>停止调度<br>注意: 停止后无法恢复, 仅用于安全退出main函数, 不保证终止所有线程.<br>如果某个调度线程被协程阻塞, 必须等待阻塞结束才能退出.</li>
</ul>
<h2 id="协程中的通信-channel"><a href="#协程中的通信-channel" class="headerlink" title="协程中的通信(channel)"></a>协程中的通信(channel)</h2><ul>
<li>无缓冲区的channel<br>channel是引用语义, 在协程间共享直接copy即可.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co_chan&lt;<span class="keyword">int</span>&gt; ch_0;</span><br><span class="line"><span class="comment">// channel是引用语义, 在协程间共享直接copy即可.</span></span><br><span class="line"><span class="comment">// 向通道写入</span></span><br><span class="line">go [=]&#123;</span><br><span class="line">	<span class="comment">// 在协程中, 向ch_0写入一个整数1.</span></span><br><span class="line">	<span class="comment">// 由于ch_0没有缓冲区, 因此会阻塞当前协程, 直到有人从ch_0中读取数据:</span></span><br><span class="line">	ch_0 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从通道读取</span></span><br><span class="line">go [=] &#123;</span><br><span class="line">  <span class="comment">// Channel是引用计数的, 复制Channel并不会产生新的Channel, 只会引用旧的Channel.</span></span><br><span class="line">  <span class="comment">// 因此, 创建协程时可以直接拷贝Channel.</span></span><br><span class="line">  <span class="comment">// Channel是mutable的, 因此可以直接使用const Channel读写数据, </span></span><br><span class="line">  <span class="comment">// 这在使用lambda表达式时是极为方便的特性.</span></span><br><span class="line">  <span class="comment">// 从ch_0中读取数据:</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	ch_0 &gt;&gt; i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>带缓冲区的channel<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缓冲区容量为1的Channel, 传递智能指针:</span></span><br><span class="line">co_chan&lt;std::shared_ptr&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ch_1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">go [=] &#123;</span><br><span class="line">	std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="built_in">p1</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 向ch_1中写入一个数据, 由于ch_1有一个缓冲区空位, 因此可以直接写入而不会阻塞当前协程.</span></span><br><span class="line">	ch_1 &lt;&lt; p1;</span><br><span class="line">	<span class="comment">// 再次向ch_1中写入整数2, 由于ch_1缓冲区已满, 因此阻塞当前协程, 等待缓冲区出现空位.</span></span><br><span class="line">	ch_1 &lt;&lt; p1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">go [=] &#123;</span><br><span class="line">	std::shared_ptr&lt;<span class="keyword">int</span>&gt; ptr;</span><br><span class="line">	<span class="comment">// 由于ch_1在执行前一个协程时被写入了一个元素, 因此下面这个读取数据的操作会立即完成.</span></span><br><span class="line">	ch_1 &gt;&gt; ptr;</span><br><span class="line">	<span class="comment">// 由于ch_1缓冲区已空, 下面这个操作会使当前协程放弃执行权, 等待第一个协程写入数据完成.</span></span><br><span class="line">	ch_1 &gt;&gt; ptr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*ptr = %d\n&quot;</span>, *ptr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li> channel的超时和非阻塞读<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co_chan&lt;<span class="keyword">int</span>&gt; ch_2;</span><br><span class="line">go [=] &#123;</span><br><span class="line"><span class="comment">// 使用TryPop和TryPush接口, 可以立即返回无需等待.</span></span><br><span class="line"><span class="comment">// 当Channel为空时, TryPop会失败; 当Channel写满时, TryPush会失败.</span></span><br><span class="line"><span class="comment">// 如果操作成功, 返回true, 否则返回false.</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> isSuccess = ch_2.<span class="built_in">TryPop</span>(val);</span><br><span class="line"><span class="comment">// 使用TimedPop和TimedPush接口, 可以在第二个参数设置等待的超时时间</span></span><br><span class="line"><span class="comment">// 如果超时, 返回false, 否则返回true.</span></span><br><span class="line"><span class="comment">// 注意：当前版本, 原生线程中使用Channel时不支持超时时间, 退化为无限期等待.</span></span><br><span class="line">isSuccess = ch_2.<span class="built_in">TimedPush</span>(<span class="number">1</span>, std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">(<span class="keyword">void</span>)isSuccess;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="协程锁-co-mutex"><a href="#协程锁-co-mutex" class="headerlink" title="协程锁(co_mutex)"></a>协程锁(co_mutex)</h2></li>
<li>co_mutex<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为展示co_mutex自动切换协程的功能，先锁住mutex</span></span><br><span class="line">cm.<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">// 标准库方式</span></span><br><span class="line"><span class="function">std::lock_guard&lt;co_mutex&gt; <span class="title">lock</span><span class="params">(cm)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">cm.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure></li>
<li>co_rwmutex读写锁<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读锁</span></span><br><span class="line">m.<span class="built_in">reader</span>().<span class="built_in">lock</span>();</span><br><span class="line">m.<span class="built_in">reader</span>().<span class="built_in">unlock</span>();</span><br><span class="line"><span class="comment">// 或使用标准库提供的lock系列的工具</span></span><br><span class="line"><span class="comment">// 读锁视图的类型为：co_rmutex</span></span><br><span class="line"><span class="function">std::unique_lock&lt;co_rmutex&gt; <span class="title">lock</span><span class="params">(m.Reader())</span></span>;</span><br><span class="line"><span class="comment">// 写锁</span></span><br><span class="line">m.<span class="built_in">writer</span>().<span class="built_in">lock</span>();</span><br><span class="line">m.<span class="built_in">writer</span>().<span class="built_in">unlock</span>();</span><br><span class="line"><span class="comment">// 或使用标准库提供的lock系列的工具</span></span><br><span class="line"><span class="comment">// 写锁视图的类型为：co_wmutex</span></span><br><span class="line"><span class="function">std::unique_lock&lt;co_wmutex&gt; <span class="title">lock</span><span class="params">(m.Writer())</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="定时器-co-timer"><a href="#定时器-co-timer" class="headerlink" title="定时器(co_timer)"></a>定时器(co_timer)</h2><ul>
<li>定时器的创建并绑定调度器<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个定时器</span></span><br><span class="line"><span class="comment">// 第一个参数: 精度</span></span><br><span class="line"><span class="comment">// 第二个参数: 绑定到一个调度器(Scheduler)</span></span><br><span class="line"><span class="comment">// 两个参数都有默认值, 可以简便地创建一个定时器: co_timer timer; </span></span><br><span class="line"><span class="function">co_timer <span class="title">timer</span><span class="params">(std::chrono::milliseconds(<span class="number">1</span>), &amp;co_sched)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>设置定时任务<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用timer.ExpireAt接口设置一个定时任务</span></span><br><span class="line"><span class="comment">// 第一个参数可以是std::chrono中的时间长度，也可以是时间点。</span></span><br><span class="line"><span class="comment">// 第二个参数是定时器回调函数</span></span><br><span class="line"><span class="comment">// 返回一个co_timer_id类型的ID, 通过这个ID可以撤销还未执行的定时函数</span></span><br><span class="line">co_timer_id id1 = timer.<span class="built_in">ExpireAt</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), []&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Timer Callback.\n&quot;</span>);&#125;);</span><br></pre></td></tr></table></figure></li>
<li>取消定时任务<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// co_timer_id::StopTimer接口可以撤销还未开始执行的定时函数</span></span><br><span class="line"><span class="comment">// 它返回bool类型的结果，如果撤销成功，返回true；</span></span><br><span class="line"><span class="comment">//     如果未来得及撤销，返回false, 此时不保证回调函数已执行完毕。</span></span><br><span class="line"><span class="keyword">bool</span> cancelled = id1.<span class="built_in">StopTimer</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cancelled:%s\n&quot;</span>, cancelled ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="协程池"><a href="#协程池" class="headerlink" title="协程池"></a>协程池</h2><ul>
<li>创建协程池<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co::AsyncCoroutinePool * pPool = co::AsyncCoroutinePool::<span class="built_in">Create</span>();</span><br></pre></td></tr></table></figure></li>
<li>初始化协程池<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以自定义协程池中的最大协程数,</span></span><br><span class="line"><span class="comment">// 建议设置的多一些, 不被执行的协程不会占用cpu资源.</span></span><br><span class="line">pPool-&gt;<span class="built_in">InitCoroutinePool</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 启动协程池</span></span><br><span class="line"><span class="comment">// 第一个参数: 最小调度线程数</span></span><br><span class="line"><span class="comment">// 第二个参数: 最大调度线程数</span></span><br><span class="line"><span class="comment">// 有效的调度线程数总是保持与最小值相同, 仅当有调度线程被阻塞住时,</span></span><br><span class="line"><span class="comment">// 才会动态扩展调度线程数.</span></span><br><span class="line">pPool-&gt;<span class="built_in">Start</span>(<span class="number">4</span>, <span class="number">128</span>);</span><br></pre></td></tr></table></figure></li>
<li>绑定回调处理函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个或多个回调处理器.</span></span><br><span class="line"><span class="comment">// 如果不绑定回调处理器, 完成回调就直接在协程池中被调用.</span></span><br><span class="line"><span class="keyword">auto</span> cbp = <span class="keyword">new</span> co::AsyncCoroutinePool::CallbackPoint;</span><br><span class="line">pPool-&gt;<span class="built_in">AddCallbackPoint</span>(cbp);  <span class="comment">// 注意只能加入, 不能删除, 要保证处理器的生命期足够长.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.以回调的方式投递任务 (适用于异步回调模型的项目)</span></span><br><span class="line"><span class="comment">// pPool-&gt;Post(&amp;foo, &amp;done);</span></span><br><span class="line">pPool-&gt;<span class="built_in">Post</span>(&amp;foo, &amp;done);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.还可以投递带返回值的回调函数, callback接受返回值, 以此形成回调链.</span></span><br><span class="line">pPool-&gt;Post&lt;<span class="keyword">int</span>&gt;(&amp;calc, &amp;callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环执行回调处理器, 直到前面投递的任务完成为止.</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="keyword">size_t</span> trigger = cbp-&gt;<span class="built_in">Run</span>();</span><br><span class="line">	<span class="keyword">if</span> (trigger &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用channel方式投递<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以Channel的方式投递任务 (适用于协程中, 或同步模型的原生线程)</span></span><br><span class="line"><span class="comment">// channel方式等待任务完成时, callback不会经过回调处理器.</span></span><br><span class="line"><span class="function">co_chan&lt;<span class="keyword">int</span>&gt; <span class="title">ch</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">pPool-&gt;Post&lt;<span class="keyword">int</span>&gt;(ch, []&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待任务完成</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">ch &gt;&gt; val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val = %d\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">// 还可以投递void返回值类型的任务</span></span><br><span class="line"><span class="function">co_chan&lt;<span class="keyword">void</span>&gt; <span class="title">ch2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">pPool-&gt;<span class="built_in">Post</span>(ch2, []&#123; <span class="built_in">printf</span>(<span class="string">&quot;void task.\n&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待任务完成</span></span><br><span class="line">ch2 &gt;&gt; <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个连接池</span></span><br><span class="line"><span class="comment">// @Factory: 创建连接的工厂</span></span><br><span class="line"><span class="comment">// @Deleter: 销毁连接, 传递NULL时会使用delete删除连接.</span></span><br><span class="line"><span class="comment">// @maxConnection: 最大连接数, 0表示不限数量</span></span><br><span class="line"><span class="comment">// @maxIdleConnection: 最大空闲连接数, 0表示不限数量</span></span><br><span class="line"><span class="comment">// 注意：Factory和Deleter的调用可能会并行.</span></span><br><span class="line"><span class="comment">//   ConnectionPool(Factory f, Deleter d = NULL, size_t maxConnection = 0, size_t maxIdleConnection = 0)</span></span><br><span class="line"><span class="function">co::ConnectionPool&lt;MySQLConnection&gt; <span class="title">cPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        []&#123; <span class="keyword">return</span> <span class="keyword">new</span> MySQLConnection; &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="literal">NULL</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">100</span>, <span class="comment">// 限制最大100个连接, 防止把mysql冲垮</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">20</span>)</span></span>; <span class="comment">// 最多保留20条空闲连接</span></span><br><span class="line"><span class="comment">// Reserve接口可以预创建一些连接, 不能超过最大空闲连接数, 即: 20</span></span><br><span class="line">cPool.<span class="built_in">Reserve</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 获取一个连接, 无限期等待</span></span><br><span class="line"><span class="comment">// @checkAliveOnGet: 申请时检查连接是否还有效, 默认NULL表示不检查</span></span><br><span class="line"><span class="comment">// @checkAliveOnPut: 归还时检查连接是否还有效, 默认NULL表示不检查</span></span><br><span class="line"><span class="comment">// @return: 返回MySQLConnection的智能指针, 引用计数归零时自动将连接还回池里.</span></span><br><span class="line"><span class="keyword">auto</span> connPtr = cPool.<span class="built_in">Get</span>();</span><br><span class="line"><span class="keyword">if</span> (connPtr) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get connection ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动归还</span></span><br><span class="line">connPtr.<span class="built_in">reset</span>();</span><br><span class="line"><span class="comment">// @return: 返回MySQLConnection的智能指针, 引用计数归零时自动将连接还回池里.</span></span><br><span class="line"><span class="comment">// 注意：在原生线程中使用时, 超时时长是不生效的.</span></span><br><span class="line">go [&amp;]&#123;</span><br><span class="line">    connPtr = cPool.<span class="built_in">Get</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">if</span> (connPtr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get connection ok.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    co_sched.<span class="built_in">Stop</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="协程局部变量"><a href="#协程局部变量" class="headerlink" title="协程局部变量"></a>协程局部变量</h2><ul>
<li>libgo的协程也有CLS(coroutine local storage)<br>同样支持TLS的三种使用场景：</li>
</ul>
<ol>
<li>块作用域(函数内)</li>
<li>全局作用域</li>
<li>类静态成员变量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个cls变量使用宏: co_cls</span></span><br><span class="line"><span class="comment">//Eg:</span></span><br><span class="line">    <span class="keyword">int</span>&amp; var = <span class="built_in">co_cls</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="built_in">co_cls_ref</span>(<span class="keyword">int</span>) var = <span class="built_in">co_cls</span>(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="co-defer"><a href="#co-defer" class="headerlink" title="co_defer"></a>co_defer</h2><ul>
<li>co_defer<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//co_defer的语法和go关键字一样, 也是后面跟一个function.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">co_defer foo;</span><br></pre></td></tr></table></figure></li>
<li>co_defer_scope可以直接在参数中写多条语句<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co_defer_scope &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
<li>defer的解除<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得上一次的defer任务</span></span><br><span class="line"><span class="keyword">auto</span> &amp; defer_obj = <span class="built_in">co_last_defer</span>();</span><br><span class="line"><span class="comment">// 解除</span></span><br><span class="line">defer_obj.<span class="built_in">dismiss</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="协程的条件变量"><a href="#协程的条件变量" class="headerlink" title="协程的条件变量"></a>协程的条件变量</h2><p>libgo协程的条件变量使用和c++11语法一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先创建互斥量和条件变量</span></span><br><span class="line">co_mutex cm;</span><br><span class="line">co_condition_variable cv2;</span><br><span class="line"><span class="comment">// 启动两个协程</span></span><br><span class="line">    go []&#123;</span><br><span class="line">      	<span class="comment">// 等待协程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lambda\n&quot;</span>);</span><br><span class="line">        <span class="function">std::unique_lock&lt;co_mutex&gt; <span class="title">lock</span><span class="params">(cm)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(pass !=<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">//pthread_cond_wait(&amp;cv,&amp;lock_);</span></span><br><span class="line">          cv2.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lambda wait over\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    go []&#123;</span><br><span class="line">    	<span class="comment">// 通知协程</span></span><br><span class="line">      cm.<span class="built_in">lock</span>();</span><br><span class="line">      pass =<span class="number">1</span>;</span><br><span class="line">      cm.<span class="built_in">unlock</span>();</span><br><span class="line">      cv2.<span class="built_in">notify_one</span>();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;notify_one\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架学习</category>
        <category>libgo</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes简介</title>
    <url>/2022/03/21/Kubernetes%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<hr>
<p>kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p>
<span id="more"></span>

<!-- toc -->


<p>[toc]</p>
<p><a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45">参考资料</a></p>
<h2 id="K8S是什么"><a href="#K8S是什么" class="headerlink" title="K8S是什么"></a>K8S是什么</h2><p>它是一个为 <strong>容器化</strong> 应用提供集群部署和管理的开源工具，由 Google 开发。</p>
<h3 id="K8S框架"><a href="#K8S框架" class="headerlink" title="K8S框架"></a>K8S框架</h3><p><img src="/2022/03/21/Kubernetes%E7%AE%80%E4%BB%8B/20220319000957.png" alt="K8S框架"></p>
<ul>
<li>master: 主节点，控制平台，不需要很高性能，不跑任务，通常一个就行了，也可以开多个主节点来提高集群可用度。</li>
<li>slave: 工作节点，可以是虚拟机或物理计算机，任务都在这里跑，机器性能需要好点；通常都有很多个，可以不断加机器扩大集群；每个工作节点由主节点管理</li>
<li>pod: 豆荚，K8S 调度、管理的最小单位，一个 Pod 可以包含一个或多个容器，每个 Pod 有自己的虚拟IP。</li>
</ul>
<h3 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h3><ul>
<li><code>kube-apiserver</code> API 服务器，公开了 Kubernetes API  </li>
<li><code>etcd</code> 键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库  </li>
<li><code>kube-scheduler</code> 调度 Pod 到哪个节点运行  </li>
<li><code>kube-controller</code> 集群控制器  </li>
<li><code>cloud-controller</code> 与云服务商交互</li>
</ul>
<p><img src="/2022/03/21/Kubernetes%E7%AE%80%E4%BB%8B/20220319001803.png" alt="K8S组件图"></p>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>这里我使用三台devcloud开发机</p>
<ul>
<li>编辑/etc/hosts</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">9.134.165.72 master</span><br><span class="line">9.135.119.203 node1</span><br><span class="line">9.135.144.179 node2</span><br></pre></td></tr></table></figure>

<ul>
<li>每台机子安装相应的软件<ul>
<li><code>docker-ce</code>: docker</li>
<li>kubelet: </li>
<li>kubeadm</li>
<li>kubectl: 集群控制器</li>
</ul>
</li>
</ul>
<p>这里要设置kubernetes的镜像源是腾讯云，tx好🐶啊</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.tencent.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.tencent.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>shell命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl docker-ce</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="主节点kubeadm初始化"><a href="#主节点kubeadm初始化" class="headerlink" title="主节点kubeadm初始化"></a>主节点kubeadm初始化</h3><ul>
<li><p>kubeadm init</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --image-repository=registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure></li>
<li><p>输出join命令行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 9.134.165.72:6443 --token 7z5l51.ehxdba3ie7zrit6i \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:b7616fe77ba3d4b14bc8ba7e6b65d37b43ed69d9e012d18b9753df227337e8d0 </span><br><span class="line"></span><br><span class="line">// </span><br><span class="line"><span class="meta">#</span><span class="bash"> 记得把 kubeadm join xxx 保存起来 <span class="comment"># 忘记了重新获取：kubeadm token create --print-join-command</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>复制授权文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 复制授权文件，以便 kubectl 可以有权限访问集群 <span class="comment"># 如果你其他节点需要访问集群，需要从主节点复制这个文件过去其他节点</span></span> </span><br><span class="line">mkdir -p $HOME/.kube </span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config </span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="工作节点加入集群"><a href="#工作节点加入集群" class="headerlink" title="工作节点加入集群"></a>工作节点加入集群</h3><ul>
<li>使用join的token (去掉换行符)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 9.134.165.72:6443 --token 7z5l51.ehxdba3ie7zrit6i --discovery-token-ca-cert-hash sha256:b7616fe77ba3d4b14bc8ba7e6b65d37b43ed69d9e012d18b9753df227337e8d0 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="控制主机查看cluster"><a href="#控制主机查看cluster" class="headerlink" title="控制主机查看cluster"></a>控制主机查看cluster</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">NAME     STATUS     ROLES                  AGE     VERSION</span><br><span class="line">master   NotReady   control-plane,master   8m37s   v1.23.5</span><br><span class="line">node1    NotReady   &lt;none&gt;                 62s     v1.23.5</span><br><span class="line">node2    NotReady   &lt;none&gt;                 49s     v1.23.5</span><br></pre></td></tr></table></figure>
<p>可以看到三台机器的集群</p>
<h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>进入ready状态<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES                  AGE     VERSION</span><br><span class="line">master   Ready    control-plane,master   11m     v1.23.5</span><br><span class="line">node1    Ready    &lt;none&gt;                 4m5s    v1.23.5</span><br><span class="line">node2    Ready    &lt;none&gt;                 3m52s   v1.23.5</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p><a href="https://github.com/HannoKishi/gin-docker-learning/tree/k8s">项目地址</a><br>ps: 使用k8s分支,<br>然后要住要镜像的cpu构架v2是arm，v3是x86</p>
<h3 id="pod文件"><a href="#pod文件" class="headerlink" title="pod文件"></a>pod文件</h3><ul>
<li><p>eg pod.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment">#指定api版本，此值必须在kubectl apiversion中  </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#指定创建资源的角色/类型  </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">#资源的元数据/属性  </span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">test-k8s</span> <span class="comment">#资源的名字，在同一个namespace中必须唯一  </span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="comment"># 定义容器，可以多个  </span></span><br><span class="line"> <span class="attr">containers:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-k8s</span> <span class="comment"># 容器名字  </span></span><br><span class="line"> <span class="attr">image:</span> <span class="string">ccr.ccs.tencentyun.com/hannokishi/k8s-test:v2</span> <span class="comment"># 镜像地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>minikube使用该yaml创建一个pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">kubectl apply -f ./pod.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">pod/test-k8s created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果</span></span><br><span class="line">NAME       READY   STATUS             RESTARTS      AGE</span><br><span class="line">test-k8s   0/1     CrashLoopBackOff   4 (42s ago)   2m23s</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="直接使用镜像地址创建pod"><a href="#直接使用镜像地址创建pod" class="headerlink" title="直接使用镜像地址创建pod"></a>直接使用镜像地址创建pod</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">kubectl run testapp --image=ccr.ccs.tencentyun.com/hannokishi/k8s-test:v3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">kubectl get pod</span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">test-k8s   1/1     Running   0          13s</span><br><span class="line">testapp    1/1     Running   0          8s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除pod</span></span><br><span class="line">kubectl delete pod podname</span><br></pre></td></tr></table></figure>


<h3 id="deployment文件"><a href="#deployment文件" class="headerlink" title="deployment文件"></a>deployment文件</h3><p>eg: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1  </span><br><span class="line">kind: Deployment  </span><br><span class="line">metadata:  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 部署名字</span>  </span><br><span class="line"> name: test-k8s  </span><br><span class="line">spec:  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 声明副本数目</span>  </span><br><span class="line"> replicas: 5  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 用来查找关联的 Pod，所有标签都匹配才行</span>  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 关联pod，通过标签 <span class="comment"># 选择器 selector:</span></span>  </span><br><span class="line">    matchLabels:  </span><br><span class="line">      app: test-k8s  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 定义 Pod 相关数据</span>  </span><br><span class="line"> template:  </span><br><span class="line">    metadata:  </span><br><span class="line">      labels:  </span><br><span class="line">        app: test-k8s  </span><br><span class="line">    spec:  </span><br><span class="line">      # 定义容器，可以多个  </span><br><span class="line"> containers:  </span><br><span class="line">        # 容器名字  </span><br><span class="line"> - name: test-k8s  </span><br><span class="line">          # 镜像路径  </span><br><span class="line"> image: ccr.ccs.tencentyun.com/hannokishi/k8s-test:v3</span><br></pre></td></tr></table></figure>

<ul>
<li>部署与查看<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 部署</span></span><br><span class="line">kubectl apply -f ./app.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">kubectl get deployment                                                 </span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">test-k8s   2/2     2            0           16s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除deployment</span></span><br><span class="line">kubectl delete deployment dplname</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="部署后控制命令演示"><a href="#部署后控制命令演示" class="headerlink" title="部署后控制命令演示"></a>部署后控制命令演示</h2><ul>
<li>部署应用<ul>
<li>kubectl apply -f app.yaml</li>
</ul>
</li>
<li>查看 deployment<ul>
<li>kubectl get deployment</li>
</ul>
</li>
<li>查看 pod<ul>
<li>kubectl get pod -o wide</li>
</ul>
</li>
<li>查看 pod 详情<ul>
<li>kubectl describe pod pod-name</li>
</ul>
</li>
<li>查看 log<ul>
<li>kubectl logs pod-name</li>
<li>kubectl logs pod-name -f</li>
</ul>
</li>
<li>进入 Pod 容器终端， -c container-name 可以指定进入哪个容器。<ul>
<li>kubectl exec -it pod-name – bash</li>
<li>kubectl exec -it pod-name – sh</li>
</ul>
</li>
<li>伸缩扩展副本 (可增可减)<ul>
<li>kubectl scale deployment test-k8s –replicas=5</li>
</ul>
</li>
<li>把集群内端口映射到节点 (可以访问服务了)<ul>
<li>kubectl port-forward pod-name 8082:8081</li>
</ul>
</li>
<li>查看历史<ul>
<li>kubectl rollout history deployment test-k8s</li>
</ul>
</li>
<li>回到上个版本<ul>
<li>kubectl rollout undo deployment test-k8s</li>
</ul>
</li>
<li>回到指定版本<ul>
<li>kubectl rollout undo deployment test-k8s –to-revision=2</li>
</ul>
</li>
<li>删除部署<ul>
<li>kubectl delete deployment test-k8s</li>
</ul>
</li>
</ul>
<h3 id="查看详细信息"><a href="#查看详细信息" class="headerlink" title="查看详细信息"></a>查看详细信息</h3><p>使用<code>kubectl get pod -o wide</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">test-k8s                    1/1     Running   0          30m   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">test-k8s-685466c884-4v6x9   1/1     Running   0          19m   172.17.0.6   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">test-k8s-685466c884-rx5q5   1/1     Running   0          19m   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">testapp                     1/1     Running   0          30m   172.17.0.4   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>可以查看ip，由于使用的是minikube，所以跑的都是一个节点</p>
<h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>使用 <code>kubectl port-forward pod-name 8082:8081</code> 将某个pod的端口映射出来<br>然后访问<code>http://localhost:8082/name</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;elapsedTime/ms&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;hostname&quot;</span>:<span class="string">&quot;test-k8s&quot;</span>,<span class="attr">&quot;method&quot;</span>:<span class="string">&quot;GET&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以得到该pod里面容器的主机名字，说明api调用成功</p>
<h3 id="实机演示"><a href="#实机演示" class="headerlink" title="实机演示"></a>实机演示</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看全部</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新部署</span></span><br><span class="line">kubectl rollout restart deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令修改镜像，--record 表示把这个命令记录到操作历史中</span></span><br><span class="line">kubectl set image deployment test-k8s test-k8s=ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v2-with-error --record</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂停运行，暂停后，对 deployment 的修改不会立刻生效，恢复后才应用设置</span></span><br><span class="line">kubectl rollout pause deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复</span></span><br><span class="line">kubectl rollout resume deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置信息输出到文件</span></span><br><span class="line">kubectl get deployment test-k8s -o yaml &gt;&gt; app2.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除全部资源</span></span><br><span class="line">kubectl delete all --all</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="工作负载分类"><a href="#工作负载分类" class="headerlink" title="工作负载分类"></a>工作负载分类</h2><ul>
<li>Deployment<br>  适合无状态应用，所有pod等价，可替代</li>
<li>StatefulSet<br>  有状态的应用，适合数据库这种类型。</li>
<li>DaemonSet<br>  在每个节点上跑一个 Pod，可以用来做节点监控、节点日志收集等</li>
<li>Job &amp; CronJob<br>  Job 用来表达的是一次性的任务，而 CronJob 会根据其时间规划反复运行。</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>  Service 通过 label 关联对应的 Pod</li>
<li>  Servcie 生命周期不跟 Pod 绑定，不会因为 Pod 重创改变 IP</li>
<li>  提供了负载均衡功能，自动转发流量到不同 Pod</li>
<li>  可对集群外部提供访问端口</li>
<li>  集群内部可通过服务名字访问<br><img src="/2022/03/21/Kubernetes%E7%AE%80%E4%BB%8B/20220319193746.png"></li>
</ul>
<h3 id="service的yaml配置"><a href="#service的yaml配置" class="headerlink" title="service的yaml配置"></a>service的yaml配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-k8s</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-k8s</span>  </span><br><span class="line">  <span class="comment"># 默认 ClusterIP 集群内可访问，NodePort 节点可访问，LoadBalancer 负载均衡模式（需要负载均衡器才可用）  </span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">NodePort</span>  </span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span>        <span class="comment"># 本 Service 的端口  </span></span><br><span class="line">	   <span class="attr">targetPort:</span> <span class="number">8081</span>  <span class="comment"># 容器端口  </span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31000</span>   <span class="comment"># 节点端口，范围固定 30000 ~ 32767</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用配置 <code>kubectl apply -f service.yaml</code></p>
<ul>
<li>服务的默认类型是<code>ClusterIP</code>，只能在集群内部访问，我们可以进入到 Pod 里面访问：</li>
<li><code>对外暴露服务</code>:上面我们是通过端口转发的方式可以在外面访问到集群里的服务，如果想要直接把集群服务暴露出来，我们可以使用<code>NodePort</code> 和 <code>Loadbalancer</code> 类型的 Service</li>
</ul>
<h2 id="StatefulSet-有状态的服务"><a href="#StatefulSet-有状态的服务" class="headerlink" title="StatefulSet 有状态的服务"></a>StatefulSet 有状态的服务</h2><h3 id="什么是-StatefulSet"><a href="#什么是-StatefulSet" class="headerlink" title="什么是 StatefulSet"></a>什么是 StatefulSet</h3><p>StatefulSet 是用来管理有状态的应用，例如数据库。</p>
<ul>
<li><p>yaml配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span>  </span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">mongodb</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">mongo:4.4</span>  </span><br><span class="line">          <span class="comment"># IfNotPresent 仅本地没有镜像时才远程拉，Always 永远都是从远程拉，Never 永远只用本地镜像，本地没有则报错  </span></span><br><span class="line"> <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>  </span><br><span class="line"><span class="meta">---  </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongodb</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  </span><br><span class="line">  <span class="comment"># HeadLess  </span></span><br><span class="line"> <span class="attr">clusterIP:</span> <span class="string">None</span>  </span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>kubectl apply -f mongo.yaml</code>启动statefulset服务</p>
</li>
<li><p><code>kubectl get pod</code>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">mongodb-0                   1/1     Running   0          2m37s</span><br><span class="line">mongodb-1                   1/1     Running   0          60s</span><br><span class="line">mongodb-2                   1/1     Running   0          59s</span><br></pre></td></tr></table></figure></li>
<li><p><code>kubectl get svc</code>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)     AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP     46h</span><br><span class="line">mongodb      ClusterIP   None         &lt;none&gt;        27017/TCP   3m1s</span><br></pre></td></tr></table></figure></li>
<li><p>连接指定pod: <code>pod-name.service-name</code></p>
<ul>
<li>pod-name.service-name相当于是hostname</li>
<li><code>mongodb --host mongodb-0.mongodb</code>来访问</li>
</ul>
</li>
</ul>
<h3 id="Web-应用连接-Mongodb"><a href="#Web-应用连接-Mongodb" class="headerlink" title="Web 应用连接 Mongodb"></a>Web 应用连接 Mongodb</h3><p>在<code>集群内部</code>，我们可以通过服务名字访问到不同的服务<br>指定连接第一个：<code>mongodb-0.mongodb</code></p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>kubernetes 集群不会为你处理数据的存储，我们可以为数据库挂载一个磁盘来确保数据的安全。<br>你可以选择云存储、本地磁盘、NFS。</p>
<ul>
<li>  本地磁盘：可以挂载某个节点上的目录，但是这需要限定 pod 在这个节点上运行</li>
<li>  云存储：不限定节点，不受集群影响，安全稳定；需要云服务商提供，裸机集群是没有的。</li>
<li>  NFS：不限定节点，不受集群影响</li>
</ul>
<h3 id="Storage-Class-SC"><a href="#Storage-Class-SC" class="headerlink" title="Storage Class (SC)"></a>Storage Class (SC)</h3><p>将存储卷划分为不同的种类，例如：SSD，普通磁盘，本地磁盘，按需使用。</p>
<h4 id="Persistent-Volume-PV"><a href="#Persistent-Volume-PV" class="headerlink" title="Persistent Volume (PV)"></a>Persistent Volume (PV)</h4><p>描述卷的具体信息，例如磁盘大小</p>
<h3 id="Persistent-Volume-Claim-PVC"><a href="#Persistent-Volume-Claim-PVC" class="headerlink" title="Persistent Volume Claim (PVC)"></a>Persistent Volume Claim (PVC)</h3><p>对存储需求的一个申明，可以理解为一个申请单，系统根据这个申请单去找一个合适的 PV<br>还可以根据 PVC 自动创建 PV。</p>
<h2 id="ConfigMap-amp-Secret"><a href="#ConfigMap-amp-Secret" class="headerlink" title="ConfigMap &amp; Secret"></a>ConfigMap &amp; Secret</h2><p>数据库连接地址，这种可能根据部署环境变化的，我们不应该写死在代码里。<br>Kubernetes 为我们提供了 ConfigMap，可以方便的配置一些变量。</p>
<h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="comment"># 名字</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-config</span></span><br><span class="line"><span class="comment"># 数据</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">mongoHost:</span> <span class="string">mongodb-0.mongodb</span></span><br></pre></td></tr></table></figure>

<h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-secret</span></span><br><span class="line"><span class="comment"># Opaque 用户定义的任意数据，更多类型介绍 https://kubernetes.io/zh/docs/concepts/configuration/secret/#secret-types</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 数据要 base64。https://tools.fun/base64.html</span></span><br><span class="line">  <span class="attr">mongo-username:</span> <span class="string">bW9uZ291c2Vy</span></span><br><span class="line">  <span class="attr">mongo-password:</span> <span class="string">bW9uZ29wYXNz</span></span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>作为环境变量放到yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mongo:4.4</span></span><br><span class="line">          <span class="comment"># IfNotPresent 仅本地没有镜像时才远程拉，Always 永远都是从远程拉，Never 永远只用本地镜像，本地没有则报错</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">mongo-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">mongo-username</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">mongo-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">mongo-password</span></span><br><span class="line">          <span class="comment"># Secret 的所有数据定义为容器的环境变量，Secret 中的键名称为 Pod 中的环境变量名称</span></span><br><span class="line">          <span class="comment"># envFrom:</span></span><br><span class="line">          <span class="comment"># - secretRef:</span></span><br><span class="line">          <span class="comment">#     name: mongo-secret</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>docker</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>c++语言运行期的强化</title>
    <url>/2022/03/28/c-%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%9A%84%E5%BC%BA%E5%8C%96/</url>
    <content><![CDATA[<p>c++11/17/20新特性学习笔记</p>
<span id="more"></span>

<!-- toc -->
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性</p>
<ul>
<li>语法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123; </span><br><span class="line">// 函数体  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>值捕获<ul>
<li> 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被<code>创建时拷贝</code>，而非调用时才拷贝</li>
</ul>
</li>
<li>引用捕获<ul>
<li> 与引用传参类似，引用捕获保存的是引用，值会发生变化</li>
</ul>
</li>
<li>隐式捕获<ul>
<li> 捕获列表中写一个 &amp; 或 = 向编译器声明采用引用捕获或者值捕获</li>
</ul>
</li>
</ul>
<p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是:</p>
<ul>
<li><code>[]</code>空捕获列表  </li>
<li><code>[name1, name2, . . . ]</code> 捕获一系列变量</li>
<li><code>[&amp;]</code> 引用捕获, 让编译器自行推导引用列表</li>
<li><code>[=]</code> 值捕获, 让编译器自行推导值捕获列表<br>c++14 允许表达式和右值捕获</li>
</ul>
<h3 id="范型lambda"><a href="#范型lambda" class="headerlink" title="范型lambda"></a>范型lambda</h3><p>c++14开始Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; </span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数对象包装器"><a href="#函数对象包装器" class="headerlink" title="函数对象包装器"></a>函数对象包装器</h2><h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型(称为闭包类型)的<code>对象</code>(称为闭包对象)，当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递。</p>
<p>C++11 std::function 是一种通用、多态的函数封装，它的实例可以对<code>任何可以调用的目标实体</code>进行存储、复制和调用操作，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹(相对来说，函数指针的调用不是类型安全的)，换句话说，就是<code>函数的容器</code>。当我们有了函数的容器之后便能够更加方便 的将函数、函数指针作为对象进行处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line">	std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line">	<span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">	std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value) -&gt; <span class="keyword">int</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>+value+important; </span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl; </span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a>std::bind 和 std::placeholder</h3><p>而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次 性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一 个新的对象，然后在参数齐全后，完成调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    ; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将参数 1,2 绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位 </span></span><br><span class="line">	<span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);  </span><br><span class="line">	<span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可  </span></span><br><span class="line">	<span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul>
<li><p>左值 (lvalue, left value)</p>
<ul>
<li> 顾名思义就是赋值符号左边的值。准确来说，左值是表达式(不一定是 赋值表达式)后依然存在的持久对象。</li>
</ul>
</li>
<li><p>右值 (rvalue, right value)</p>
<ul>
<li> 右边的值，是指表达式结束后就不再存在的临时对象。<br>c++11将右值进一步划分为<code>纯右值</code>和<code>将亡值</code></li>
</ul>
</li>
<li><p>纯右值 (prvalue, pure rvalue)</p>
<ul>
<li> 纯粹的右值，要么是纯粹的字面量，例如 10, true;要么是求值 结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原 始字面量、Lambda 表达式都属于纯右值。<br>ps :  字符串字面量只有在类中才是右值，当其位于普通函数中是左值</li>
</ul>
</li>
<li><p>将亡值 (xvalue, expiring value)</p>
<ul>
<li> 也就是即将被销毁、却能够被移动的值。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大，这将造成大量 额外的开销</p>
<h3 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h3><p>要拿到一个将亡值，就需要用到右值引用:T &amp;&amp;，其中 T 是类型。右值引用的声明让这个临时值的 生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p>
<p>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获 得一个右值临时对象</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> *pointer;</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 构造&quot;</span> &lt;&lt; pointer &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*a.pointer)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line"><span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123;</span><br><span class="line">	a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 移动&quot;</span> &lt;&lt; pointer &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 析构&quot;</span> &lt;&lt; pointer &lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">delete</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="keyword">bool</span> test)</span> </span>&#123;</span><br><span class="line">	A a,b;</span><br><span class="line">	<span class="keyword">if</span>(test)</span><br><span class="line">		<span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> b; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// return_rvalue返回的是一个右值引用</span></span><br><span class="line"><span class="comment">//函数返回后，产生一个将亡值,被A的移动构造(A(A&amp;&amp;))引用，从而延长生命周期，并将这</span></span><br><span class="line"><span class="comment">//个右值中的指针拿到，保存到了obj中，</span></span><br><span class="line">	A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 构造0x258ac20</span></span><br><span class="line"><span class="comment">// 构造0x258ac40</span></span><br><span class="line"><span class="comment">// 移动0x258ac40</span></span><br><span class="line"><span class="comment">// 析构0</span></span><br><span class="line"><span class="comment">// 析构0x258ac20</span></span><br><span class="line"><span class="comment">// obj:</span></span><br><span class="line"><span class="comment">// 0x258ac40</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 析构0x258ac40</span></span><br></pre></td></tr></table></figure>

<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p><code>一个声明的右值引用其实是一个左值。</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;  </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123; </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 普通传参:&quot;</span>;</span><br><span class="line">	<span class="built_in">reference</span>(v); <span class="comment">// 始终调用 reference(int&amp;) </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	<span class="built_in">pass</span>(<span class="number">1</span>); <span class="comment">// 1 是右值, 但输出是左值</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>;  </span><br><span class="line">	<span class="built_in">pass</span>(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传递右值:</span></span><br><span class="line"><span class="comment">// 普通传参: 左值</span></span><br><span class="line"><span class="comment">// 传递左值:</span></span><br><span class="line"><span class="comment">// 普通传参: 左值</span></span><br></pre></td></tr></table></figure>
<p>对于 pass(1) 来说，虽然传递的是右值，但由于 v 是一个引用，所以同时也是左值。因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。</p>
<ul>
<li><code>引用坍缩规则</code><ul>
<li> 在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由 于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数形参类型</th>
<th align="center">实参参数类型</th>
<th align="center">推导后函数形参类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T&amp;</td>
<td align="center">左引用</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;</td>
<td align="center">右引用</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">左引用</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">右引用</td>
<td align="center">T&amp;&amp;</td>
</tr>
<tr>
<td align="center"><code>行参和实参都是右引用，结果才为右引用</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>因此，模板函数中使用 T&amp;&amp; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。 更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为 右引用类型</p>
<p>使用<code>std::forward</code>来进行参数的转发:</p>
<ul>
<li>在传递参数的时候，保持原来 的参数类型(左引用保持左引用，右引用保持右引用)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot; 左值引用&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot; 右值引用&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;         普通传参: &quot;</span>;</span><br><span class="line">  <span class="built_in">reference</span>(v);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;       std::move传参: &quot;</span>;</span><br><span class="line">  <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;   std::forward 传参: &quot;</span>;</span><br><span class="line">  <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot; static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">  <span class="built_in">reference</span>(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">  <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">  <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">pass</span>(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 传递右值:</span><br><span class="line">         普通传参:  左值引用</span><br><span class="line">       std::move传参:  右值引用</span><br><span class="line">   std::forward 传参:  右值引用</span><br><span class="line"> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt; 传参:  右值引用</span><br><span class="line"> 传递左值:</span><br><span class="line">         普通传参:  左值引用</span><br><span class="line">       std::move传参:  右值引用</span><br><span class="line">   std::forward 传参:  左值引用</span><br><span class="line"> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt; 传参:  左值引用</span><br></pre></td></tr></table></figure>
<p>通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。<br>当 <code>std::forward</code> 接受左值时，_Tp 被推导为左值，而所以返回值为左值;而当其接受右值时，_Tp 被推导为右值引用，则基于坍缩规则，返回值便成为了 &amp;&amp; + &amp;&amp; 的右值。</p>
]]></content>
      <categories>
        <category>语言学习</category>
        <category>c++</category>
        <category>现代c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>docker下搭建wordpress站点</title>
    <url>/2022/01/17/docker%E4%B8%8B%E6%90%AD%E5%BB%BAwordpress%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<hr>
<p>[toc]</p>
<h2 id="为什么要搭建一个wordpress站点"><a href="#为什么要搭建一个wordpress站点" class="headerlink" title="为什么要搭建一个wordpress站点"></a>为什么要搭建一个wordpress站点</h2><p>想写博客了，记录自己技术上的成长(😊)。wordpress是一个动态站点（对比github加hexo搭建的）。wordpress服务器搭建的网站，优点在于互动很容易比如评论，页面设计比较自由等。但是缺点是需要自己配置数据库存数据，而且很多配置文件并不是存到数据库中的，移植性很差。文章格式并不是原生支持markdown格式，需要装插件。最终选择了使用hexo加github那一套，毕竟文章笔记都是md格式文件，移植性高，配置和环境文件还有github兜底，不至于后面会出现丢数据情况。</p>
<span id="more"></span>
<!-- toc -->


<h2 id="如何搭建一个wordpress"><a href="#如何搭建一个wordpress" class="headerlink" title="如何搭建一个wordpress"></a>如何搭建一个wordpress</h2><blockquote>
<p>准备工作</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> wordpress的docker镜像</li>
<li><input disabled="" type="checkbox"> mysql8.0的docker镜像</li>
</ul>
<p><code>docker查看当前拥有的镜像</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<img src="3894430218373.png" width="50%">


<blockquote>
<p>镜像的运行</p>
</blockquote>
<h3 id="前置事项-需要创建属于mysql自己的配置文件-因为挂载了目录的缘故吧"><a href="#前置事项-需要创建属于mysql自己的配置文件-因为挂载了目录的缘故吧" class="headerlink" title="前置事项: 需要创建属于mysql自己的配置文件(因为挂载了目录的缘故吧)"></a>前置事项: 需要创建属于mysql自己的配置文件(因为挂载了目录的缘故吧)</h3><p>在mysql目录下创建一个my.cnf文件，内容如下: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">secure_file_priv=/var/lib/mysql</span><br><span class="line">expire_logs_days=7</span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">max_connections=1000</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>

<h3 id="首先我们的服务器上要安装mysql8-0"><a href="#首先我们的服务器上要安装mysql8-0" class="headerlink" title="首先我们的服务器上要安装mysql8.0"></a>首先我们的服务器上要安装mysql8.0</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--restart=always \</span><br><span class="line">--privileged=true \</span><br><span class="line">-p 3306:3306 --name mysql \</span><br><span class="line">-v /home/ubuntu/mysql/log:/var/log/mysql \</span><br><span class="line">-v /home/ubuntu/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /home/ubuntu/mysql/my.cnf:/etc/mysql/my.cnf \</span><br><span class="line">-v /home/ubuntu/mysql/conf.d:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">-d mysql:8.0</span><br></pre></td></tr></table></figure>
<p><code>这里需要注意的事</code>:</p>
<ul>
<li>–restart: 选项是当mysql运行停止后，自动重启的选项</li>
<li>–p: 端口映射，本机端口:docker镜像端口</li>
<li>–name: 运行的容器名字</li>
<li>-v: 目录挂载(<strong>很重要</strong>)，将mysql的数据在本地保存一份</li>
<li>-e: 设置环境变量，该命令是为了产生一个mysql的root用户，密码是123456</li>
<li>-d: 后台运行</li>
</ul>
<p><code>运行mysql容器成功</code>:<br>通过ps命令查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<img src="5470225775896.png" width="50%">



<h3 id="wordpress容器的启动"><a href="#wordpress容器的启动" class="headerlink" title="wordpress容器的启动"></a>wordpress容器的启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name some-wordpress --network=host -d wordpress:beta-php8.1</span><br></pre></td></tr></table></figure>
<p><code>注意</code></p>
<ul>
<li>选用–network=host 保证wordpress与主机网络环境一致</li>
<li>–network = host 可以避免容器之间通信的麻烦，比如wordpress需要访问mysql8.0的容器<br>启动成功<img src="4611744564988.png" width="50%"></li>
</ul>
<h2 id="wordpress登录"><a href="#wordpress登录" class="headerlink" title="wordpress登录"></a>wordpress登录</h2><p>使用默认端口80登录<br><img src="3180015900739.png" width="50%"></p>
<p><strong>为了复用原先mysql数据库的表(wordpress的网页代码都是存到表里面的)</strong><br>我们需要使用同一个表名</p>
<p><code>由于使用了别的模版</code><br>wordpress无法解析，因此需要重新去下载主题和插件(所以这里我认为，模版主题和插件是存在容器中的，当删除重启，这些插件都需要重新下载)<br><img src="3015483849143.png" width="50%"></p>
<p><code>重新安装回mynote主题</code></p>
<img src="1038716535785.png" width="50%">
一切正常，文章也都还在。

<h2 id="WordPress的使用"><a href="#WordPress的使用" class="headerlink" title="WordPress的使用"></a>WordPress的使用</h2><h3 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h3><ul>
<li>WP Githuber MD – WordPress Markdown 语法编辑器: 使用markdown写网页</li>
</ul>
<h3 id="菜单相关"><a href="#菜单相关" class="headerlink" title="菜单相关"></a>菜单相关</h3><img src="3172019082263.png" width="50%">
通过菜单将新增的页面添加进去，将在菜单上增加导航

<h3 id="小工具相关"><a href="#小工具相关" class="headerlink" title="小工具相关"></a>小工具相关</h3><p>该功能相当于布局整个页面模块</p>
]]></content>
      <categories>
        <category>服务器部署</category>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>docker</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>docker简介</title>
    <url>/2022/03/19/docker%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<hr>
<p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，  而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p>
<span id="more"></span>

<!-- toc -->

<p>[toc]</p>
<p><a href="docker.easydoc.net">教程推荐</a></p>
<h2 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h2><h2 id="打包，分发，部署"><a href="#打包，分发，部署" class="headerlink" title="打包，分发，部署"></a>打包，分发，部署</h2><ul>
<li><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包  </li>
<li><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装  </li>
<li><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows/Mac/Linux。</li>
</ul>
<h2 id="docker-run快速安装"><a href="#docker-run快速安装" class="headerlink" title="docker run快速安装"></a>docker run快速安装</h2><p><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run命令参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis redis:latest</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--detach</code> , <code>-d</code> : Run container in background and print container ID（后台运行）</li>
<li><code>--publish</code> , <code>-p</code> : Publish a container’s port(s) to the host（指定端口映射）</li>
<li><code>--name</code> : Assign a name to the container（指定容器名字）</li>
<li>-i: 选项指示 docker 要在容器上打开一个标准的输入接口</li>
<li>-t: 指示 docker 要创建一个伪 tty 终端，连接容器的标准输入接口，之后用户就可以通过终端进行输入。</li>
</ul>
<h2 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h2><p><a href="https://github.com/HannoKishi/gin-docker-learning">项目地址</a></p>
<h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>ps: 这里goweb是我使用golang的gin框架编写的简单的web服务器的二进制。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest  </span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="string">&quot;enming&quot;</span>  </span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /app  </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install wget</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span>  </span><br><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="string">&quot;./goweb&quot;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>FROM: 基于from镜像</li>
<li>RUN: 用于执行后面跟着的命令行命令，Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。</li>
<li>MAINTAINTER: 制作人名字</li>
<li>COPY: 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</li>
<li>ADD: ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。</li>
<li>CMD: 类似于 RUN 指令，用于运行程序.<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
</ul>
</li>
<li>ENV: 设置环境变量，定义了环境变量</li>
<li>EXPOSE: 仅仅只是声明端口。</li>
<li>WORKDIR: 指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。</li>
</ul>
<h3 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 在dockerfile的目录下</span><br><span class="line">// gin_test: 镜像名字</span><br><span class="line">// v1: 版本号</span><br><span class="line">docker build -t gin_test:v1 .</span><br></pre></td></tr></table></figure>

<h4 id="这里有个坑"><a href="#这里有个坑" class="headerlink" title="这里有个坑"></a>这里有个坑</h4><p><a href="https://docs.docker.com/desktop/multi-arch/">多构架镜像</a><br>对于不同cpu构架需要不同的镜像编译，这里提供一个多构架镜像编译</p>
<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8081 --name test-gin gin_test:v1</span><br></pre></td></tr></table></figure>
<h3 id="通过curl命令查看docker的web服务器部署"><a href="#通过curl命令查看docker的web服务器部署" class="headerlink" title="通过curl命令查看docker的web服务器部署"></a>通过curl命令查看docker的web服务器部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;&#123;&quot;username&quot;:&quot;123&quot;&#125; -X POST&#x27; 127.0.0.1:8081</span><br><span class="line"></span><br><span class="line">&#123;&quot;elapsedTime/ms&quot;:6,&quot;method&quot;:&quot;POST&quot;,&quot;username&quot;:&quot;123&quot;&#125;%</span><br></pre></td></tr></table></figure>

<h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v /test:/soft centos /bin/bash</span><br><span class="line"></span><br><span class="line">这样在容器启动后，容器内会自动创建/soft的目录。通过这种方式，我们可以明确一点，即-v参数中，冒号&quot;:&quot;前面的目录是宿主机目录，后面的目录是容器内目录。</span><br></pre></td></tr></table></figure>
<p>ps: 要使用相对目录，若容器删除，本机目录仍会保留</p>
<h2 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h2><ul>
<li><code>docker ps</code> 查看当前运行中的容器  </li>
<li><code>docker images</code> 查看镜像列表  </li>
<li><code>docker rm container-id</code> 删除指定 id 的容器  </li>
<li><code>docker stop/start container-id</code> 停止/启动指定 id 的容器  </li>
<li><code>docker rmi image-id</code> 删除指定 id 的镜像  </li>
<li><code>docker volume ls</code> 查看 volume 列表  </li>
<li><code>docker network ls</code> 查看网络列表</li>
</ul>
<h2 id="多容器通信"><a href="#多容器通信" class="headerlink" title="多容器通信"></a>多容器通信</h2><h3 id="使用虚拟网络"><a href="#使用虚拟网络" class="headerlink" title="使用虚拟网络"></a>使用虚拟网络</h3><p>要想多容器之间互通，从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了。</p>
<h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create test-net</span><br></pre></td></tr></table></figure>
<p>创建一个名为<code>test-net</code>的网络</p>
<h3 id="指定redis网络运行容器"><a href="#指定redis网络运行容器" class="headerlink" title="指定redis网络运行容器"></a>指定redis网络运行容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis --network test-net --network-alias redis redis:latest`</span><br></pre></td></tr></table></figure>
<p>这里 –network-alias相当于指定hostname</p>
<h3 id="指定web服务运行的network"><a href="#指定web服务运行的network" class="headerlink" title="指定web服务运行的network"></a>指定web服务运行的network</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8081:8081 --name test --network test-net -d gin_test2:v1</span><br></pre></td></tr></table></figure>
<p>在服务器的代码中，redis的地址可以使用别名<code>redis</code></p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;context&quot;</span>  </span><br><span class="line"> <span class="string">&quot;fmt&quot;</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span> <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span> <span class="string">&quot;net/http&quot;</span> <span class="string">&quot;os&quot;</span> <span class="string">&quot;strconv&quot;</span> <span class="string">&quot;time&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Username <span class="keyword">string</span> <span class="string">`json:&quot;username&quot;`</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   engine := gin.Default()  </span><br><span class="line">  </span><br><span class="line">   engine.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;  </span><br><span class="line">      startTime := time.Now()  </span><br><span class="line">  </span><br><span class="line">      c.JSON(http.StatusOK, gin.H&#123;  </span><br><span class="line">         <span class="string">&quot;method&quot;</span>:         http.MethodGet,  </span><br><span class="line"> <span class="string">&quot;elapsedTime/ms&quot;</span>: time.Since(startTime).Milliseconds(),  </span><br><span class="line"> &#125;)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   engine.POST(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;  </span><br><span class="line">      startTime := time.Now()  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">var</span> u User  </span><br><span class="line"> err := c.BindJSON(&amp;u)  </span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         c.JSON(http.StatusOK, gin.H&#123;  </span><br><span class="line">            <span class="string">&quot;error&quot;</span>: err.Error(),  </span><br><span class="line"> &#125;)  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">      c.JSON(http.StatusOK, gin.H&#123;  </span><br><span class="line">         <span class="string">&quot;method&quot;</span>:         http.MethodPost,  </span><br><span class="line"> <span class="string">&quot;elapsedTime/ms&quot;</span>: time.Since(startTime).Milliseconds(),  </span><br><span class="line"> <span class="string">&quot;username&quot;</span>:       u.Username,  </span><br><span class="line"> &#125;)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 增加一个redis访问,这里的hostname选用  --network-alias设置的别名</span></span><br><span class="line"> rdb := redis.NewClient(&amp;redis.Options&#123;  </span><br><span class="line">      Addr:     <span class="string">&quot;redis:6379&quot;</span>,  </span><br><span class="line"> Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set  </span></span><br><span class="line"> DB:       <span class="number">0</span>, <span class="comment">// use default DB  </span></span><br><span class="line"> &#125;)  </span><br><span class="line">   ctx:= context.Background()  </span><br><span class="line">   pong, err := rdb.Ping(ctx).Result()  </span><br><span class="line">   fmt.Println(pong, err)  </span><br><span class="line">   <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;  </span><br><span class="line">      os.Exit(<span class="number">-1</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">   _,err = rdb.Get(ctx,<span class="string">&quot;key&quot;</span>).Result()  </span><br><span class="line">   <span class="comment">// 不存在key则创建  </span></span><br><span class="line"> <span class="keyword">if</span> err==redis.Nil&#123;  </span><br><span class="line">      _,err = rdb.Set(ctx,<span class="string">&quot;key&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="number">0</span>).Result()  </span><br><span class="line">      <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;  </span><br><span class="line">         fmt.Println(err)  </span><br><span class="line">         os.Exit(<span class="number">-1</span>)  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   engine.GET(<span class="string">&quot;/redis&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;  </span><br><span class="line">      startTime := time.Now()  </span><br><span class="line">      val ,err:= rdb.Get(ctx,<span class="string">&quot;key&quot;</span>).Result()  </span><br><span class="line">      <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;  </span><br><span class="line">         c.JSON(http.StatusOK, gin.H&#123;  </span><br><span class="line">            <span class="string">&quot;method&quot;</span>:         http.MethodGet,  </span><br><span class="line"> <span class="string">&quot;elapsedTime/ms&quot;</span>: time.Since(startTime).Milliseconds(),  </span><br><span class="line"> <span class="string">&quot;err&quot;</span>:<span class="string">&quot;Redis Get Key Error&quot;</span>,  </span><br><span class="line"> &#125;)  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">      current,_ := strconv.Atoi(val)  </span><br><span class="line">      _,err = rdb.Set(ctx,<span class="string">&quot;key&quot;</span>,current+<span class="number">1</span>,<span class="number">0</span>).Result()  </span><br><span class="line">      <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;  </span><br><span class="line">         c.JSON(http.StatusOK, gin.H&#123;  </span><br><span class="line">            <span class="string">&quot;method&quot;</span>:         http.MethodGet,  </span><br><span class="line"> <span class="string">&quot;elapsedTime/ms&quot;</span>: time.Since(startTime).Milliseconds(),  </span><br><span class="line"> <span class="string">&quot;err&quot;</span>:<span class="string">&quot;Redis Set Key Error&quot;</span>,  </span><br><span class="line"> &#125;)  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">      c.JSON(http.StatusOK, gin.H&#123;  </span><br><span class="line">         <span class="string">&quot;method&quot;</span>:         http.MethodGet,  </span><br><span class="line"> <span class="string">&quot;elapsedTime/ms&quot;</span>: time.Since(startTime).Milliseconds(),  </span><br><span class="line"> <span class="string">&quot;redisKey&quot;</span>:current+<span class="number">1</span>,  </span><br><span class="line"> &#125;)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   engine.Run(<span class="string">&quot;:8081&quot;</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h3><ul>
<li>post<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;&#123;&quot;username&quot;:&quot;123&quot;&#125; -X POST&#x27; 127.0.0.1:8081</span><br><span class="line">&#123;&quot;elapsedTime/ms&quot;:10,&quot;method&quot;:&quot;POST&quot;,&quot;username&quot;:&quot;123&quot;&#125;%</span><br></pre></td></tr></table></figure></li>
<li>get<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl  -X GET 127.0.0.1:8081/redis</span><br><span class="line">&#123;&quot;elapsedTime/ms&quot;:1,&quot;method&quot;:&quot;GET&quot;,&quot;redisKey&quot;:21&#125;%</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><p>使用docker-compose将多个服务集合到一起，一键运行。<br><a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file">配置模版与详细参数</a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">services:</span>  </span><br><span class="line">  <span class="attr">app:</span>  </span><br><span class="line">    <span class="attr">build:</span> <span class="string">./</span>  </span><br><span class="line">    <span class="attr">ports:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="number">8082</span><span class="string">:8081</span>  </span><br><span class="line">    <span class="attr">volumes:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span>  </span><br><span class="line">    <span class="attr">environment:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>  </span><br><span class="line">  <span class="attr">redis:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span>  </span><br><span class="line">    <span class="attr">volumes:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis:/data</span>  </span><br><span class="line">    <span class="attr">environment:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">volumes:</span>  </span><br><span class="line">  <span class="attr">redis:</span></span><br></pre></td></tr></table></figure>
<ul>
<li>services: 开启的服务，对应相应容器</li>
<li>build: 执行dockerfile的build</li>
<li>ports: 端口映射</li>
<li>volumes: 宿主机与容器对应的挂载映射</li>
<li>environment: 环境变量设置</li>
<li>image: 镜像名字,如果没有则尝试拉去</li>
<li>volumes/redis: 定义宿主机器redis变量的位置</li>
</ul>
<h3 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h3><p>在<code>docker-compose.yml</code> 文件所在目录，执行：<code>docker-compose up</code>就可以跑起来了。</p>
<ul>
<li>运行应用程序堆栈后台<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
在后台运行只需要加一个 -d 参数<code>docker-compose up -d</code><br>查看运行状态：<code>docker-compose ps</code><br>停止运行：<code>docker-compose stop</code><br>重启：<code>docker-compose restart</code><br>重启单个服务：<code>docker-compose restart service-name</code><br>进入容器命令行：<code>docker-compose exec service-name sh</code><br>查看容器运行log：<code>docker-compose logs [service-name]</code></li>
</ul>
<h2 id="镜像上传"><a href="#镜像上传" class="headerlink" title="镜像上传"></a>镜像上传</h2><h3 id="首先要登陆"><a href="#首先要登陆" class="headerlink" title="首先要登陆"></a>首先要登陆</h3><ul>
<li>这里我使用的腾讯云<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login --username=100008323897 ccr.ccs.tencentyun.com/longdbtencentdocker/publongdb</span><br></pre></td></tr></table></figure>
<h3 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h3></li>
<li>要提前在腾讯云创建命名空间<ul>
<li>这里我提前创建了一个hannokishi的命名空间<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag XXXXXXX ccr.ccs.tencentyun.com/命名空间/名称:版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> eg:</span></span><br><span class="line">docker tag gin-docker-learning_app ccr.ccs.tencentyun.com/hannokishi/k8s-test:v1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> push命令</span></span><br><span class="line">docker push ccr.ccs.tencentyun.com/hannokishi/k8s-test:v1</span><br><span class="line"><span class="meta">#</span><span class="bash"> push结果</span></span><br><span class="line">The push refers to repository [ccr.ccs.tencentyun.com/hannokishi/k8s-test]</span><br><span class="line">5f70bf18a086: Pushed</span><br><span class="line">a4eb62abdd2f: Pushed</span><br><span class="line">534ef0372885: Pushed</span><br><span class="line">v1: digest: sha256:fdac2dacf32ba833df1076a93fe7d1500e4eabc8d1193670271f17b57f712a52 size: 946</span><br></pre></td></tr></table></figure>

<ul>
<li>得到一个镜像地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ccr.ccs.tencentyun.com/hannokishi/k8s-test</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的大小堆heap实现</title>
    <url>/2022/05/04/golang%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%A0%86heap%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在leetcode刷题时候，会用到大小堆的数据结构。在go语言中，大小堆的实现是有现成的接口的。</p>
<span id="more"></span>

<!-- toc -->


<h2 id="container-heap包"><a href="#container-heap包" class="headerlink" title="container/heap包"></a>container/heap包</h2><p>在go语言中，<code>container/heap</code>包中存在一个接口。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;  </span><br><span class="line"> sort.Interface  </span><br><span class="line"> Push(x any) <span class="comment">// add x as element Len()  </span></span><br><span class="line"> Pop() any   <span class="comment">// remove and return element Len() - 1.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现该接口需要实现具体的方法。</p>
<ul>
<li><code>sort.Interface</code>接口（sort包中）</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;  </span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// See Float64Slice.Less for a correct implementation for floating-point values.</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此要实现一个指定数据结构的大小堆需要实现一下的方法：</p>
<ul>
<li>Push(x any) : 增加一个元素</li>
<li>Pop() any : 返回一个元素</li>
<li>Len() int : 返回长度</li>
<li>Less(i, j int) bool : 元素大小比较方法</li>
<li>Swap(i, j int) : 交换元素方法</li>
</ul>
<h2 id="以int类型举例大小堆"><a href="#以int类型举例大小堆" class="headerlink" title="以int类型举例大小堆"></a>以int类型举例大小堆</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个基于int数组的堆</span></span><br><span class="line"><span class="keyword">type</span> minHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 sort的三个方法</span></span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里如果是小于，那么实现的是小根堆，如果是大于实现的是大根堆</span></span><br><span class="line">	<span class="comment">// 这是Swap的前置交换条件</span></span><br><span class="line">	<span class="keyword">return</span> h[i] &lt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写heap的push和pop方法</span></span><br><span class="line"><span class="comment">// 看源码知道，push方法只需要在数据集末尾增加值v</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, v.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 看源码知道，pop方法是将最后一个值删除并返回</span></span><br><span class="line"><span class="comment">// 这个不好理解，按我们的理解，pop应该是取根节点 也就是删除第一个值</span></span><br><span class="line"><span class="comment">// 实际上注意我们使用的是工具包，这个Pop不是真正的Pop</span></span><br><span class="line"><span class="comment">// 工具包的Pop会将根节点和尾节点先进行交换，所以我们此时的Pop只需要删除最后一个值返回就好</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	last := <span class="built_in">len</span>(*h) - <span class="number">1</span></span><br><span class="line">	v := (*h)[last]</span><br><span class="line">	*h = (*h)[:last]</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong> 这里的pop需要注意，我们理解应该是pop最大最小堆的根节点，但实际上是我们调用<code>heap.Pop()</code>然后该函数里面在调用接口的<code>Pop()</code>，在这之前，会将最后的元素和第一个元素交换。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;container/heap&quot;</span>  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   h := minHeap&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;  </span><br><span class="line">   <span class="comment">// 打印原来的数据集  </span></span><br><span class="line">   fmt.Println(h)  <span class="comment">// [5 4 3 2 1]</span></span><br><span class="line">   <span class="comment">// 初始化数据集变成堆  </span></span><br><span class="line">   heap.Init(&amp;h)  </span><br><span class="line">   fmt.Println(h)  <span class="comment">// [1 2 3 5 4]</span></span><br><span class="line">   <span class="comment">// 增加一个值  </span></span><br><span class="line">   heap.Push(&amp;h, <span class="number">6</span>)</span><br><span class="line">   fmt.Println(h)  <span class="comment">// [1 2 3 5 4 6]  </span></span><br><span class="line">   <span class="comment">// 根节点出堆  </span></span><br><span class="line">   heap.Pop(&amp;h)  </span><br><span class="line">   fmt.Println(h)  <span class="comment">// [2 4 3 5 6]</span></span><br><span class="line">   <span class="comment">// 删除第i个值  </span></span><br><span class="line">   heap.Remove(&amp;h, <span class="number">2</span>)  </span><br><span class="line">   fmt.Println(h)  <span class="comment">// [2 4 6 5]</span></span><br><span class="line">   <span class="comment">// 修改第2个值为v  </span></span><br><span class="line">   h[<span class="number">2</span>] = <span class="number">1</span>  </span><br><span class="line">   <span class="comment">// fix方法是在第i个值被修改后，基于修改值构建堆  </span></span><br><span class="line">   heap.Fix(&amp;h, <span class="number">2</span>)  </span><br><span class="line">   fmt.Println(h)  <span class="comment">// [1 4 2 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="以ListNode类型举例"><a href="#以ListNode类型举例" class="headerlink" title="以ListNode类型举例"></a>以ListNode类型举例</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.  </span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;  </span><br><span class="line">  Val <span class="keyword">int</span>  </span><br><span class="line">  Next *ListNode  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> maxHeap []*ListNode  </span><br><span class="line"><span class="comment">// 长度  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(h maxHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(h)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 比较规则  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> h[i].Val &gt; h[j].Val  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 交换规则  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>&#123;  </span><br><span class="line">   h[i],h[j] = h[j],h[i]  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// push  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(h *maxHeap)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   *h = <span class="built_in">append</span>(*h,v.(*ListNode))  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// pop  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h * maxHeap)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;  </span><br><span class="line">   last := <span class="built_in">len</span>(*h) - <span class="number">1</span>  </span><br><span class="line">   v := (*h)[last]  </span><br><span class="line">   *h = (*h)[:last]  </span><br><span class="line">   <span class="keyword">return</span> v  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="comment">// list表  </span></span><br><span class="line">   l1 := &amp;ListNode&#123;<span class="number">1</span>,<span class="literal">nil</span>&#125;  </span><br><span class="line">   l2 := &amp;ListNode&#123;<span class="number">2</span>,<span class="literal">nil</span>&#125;  </span><br><span class="line">   l3 := &amp;ListNode&#123;<span class="number">3</span>,<span class="literal">nil</span>&#125;  </span><br><span class="line">   l4 := &amp;ListNode&#123;<span class="number">4</span>,<span class="literal">nil</span>&#125;  </span><br><span class="line">   l5 := &amp;ListNode&#123;<span class="number">5</span>,<span class="literal">nil</span>&#125;  </span><br><span class="line">   part := maxHeap&#123;l1,l2,l3,l4,l5&#125;  </span><br><span class="line">   <span class="keyword">for</span> _,i := <span class="keyword">range</span> part&#123;  </span><br><span class="line">      fmt.Print(i.Val)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Println() <span class="comment">// 12345  </span></span><br><span class="line">   <span class="comment">// 初始化   heap.Init(&amp;part)  </span></span><br><span class="line">   <span class="keyword">for</span> _,i := <span class="keyword">range</span> part&#123;  </span><br><span class="line">      fmt.Print(i.Val)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Println() <span class="comment">// 54312  </span></span><br><span class="line">   <span class="comment">// 增加值   heap.Push(&amp;part,&amp;ListNode&#123;7,nil&#125;)  </span></span><br><span class="line">   <span class="keyword">for</span> _,i := <span class="keyword">range</span> part&#123;  </span><br><span class="line">      fmt.Print(i.Val)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Println() <span class="comment">// 745123  </span></span><br><span class="line">   <span class="comment">// 移除值   heap.Pop(&amp;part)  </span></span><br><span class="line">   <span class="keyword">for</span> _,i := <span class="keyword">range</span> part&#123;  </span><br><span class="line">      fmt.Print(i.Val)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Println() <span class="comment">// 54312  </span></span><br><span class="line">   <span class="comment">// 修改某个值之后重新排列   part[3].Val = 7  </span></span><br><span class="line">   heap.Fix(&amp;part,<span class="number">3</span>)  </span><br><span class="line">   <span class="keyword">for</span> _,i := <span class="keyword">range</span> part&#123;  </span><br><span class="line">      fmt.Print(i.Val)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Println() <span class="comment">// 75342  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>kafka简介</title>
    <url>/2022/02/16/kafka%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<hr>
<p>Apache Kafka 是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使你能够将消息从一个端点传递到另一个端点。 Kafka 适合离线和在线消息消费。 Kafka 消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka 构建在 ZooKeeper 同步服务之上。 它与 Apache Storm 和 Spark 非常好地集成，用于实时流式数据分析。</p>
<p>由于项目的日志要通过filebeat入kafka，因此初步简单的了解下kafka。</p>
<span id="more"></span>
<!-- toc -->

<p>[toc]</p>
<p>Kafka 是一个分布式消息队列，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><strong>生产者和消费者（producer和consumer）</strong>：消息的发送者叫 Producer，消息的使用者和接受者是 Consumer，生产者将数据保存到 Kafka 集群中，消费者从中获取消息进行业务的处理。</li>
<li><strong>broker</strong>：Kafka 集群中有很多台 Server，其中每一台 Server 都可以存储消息，将每一台 Server 称为一个 kafka 实例，也叫做 broker。</li>
<li><strong>主题（topic）</strong>：一个 topic 里保存的是同一类消息，相当于对消息的分类，每个 producer 将消息发送到 kafka 中，都需要指明要存的 topic 是哪个，也就是指明这个消息属于哪一类。</li>
<li><strong>分区（partition）</strong>：每个 topic 都可以分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被直接追加到 log 文件的尾部。为什么要进行分区呢？最根本的原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区的办法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。</li>
<li><strong>偏移量（Offset）</strong>：一个分区对应一个磁盘上的文件，而消息在文件中的位置就称为 offset（偏移量），offset 为一个 long 型数字，它可以唯一标记一条消息。由于kafka 并没有提供其他额外的索引机制来存储 offset，文件只能顺序的读写，所以在kafka中几乎不允许对消息进行“随机读写”。</li>
</ul>
<p>综上，我们总结一下 Kafka 的几个要点:</p>
<ul>
<li>  kafka 是一个基于发布-订阅的分布式消息系统<strong>（消息队列）</strong></li>
<li>  Kafka 面向大数据，消息保存在主题中，而每个 topic 有分为多个分区</li>
<li>  kafka 的消息数据保存在磁盘，<code>每个 partition 对应磁盘上的一个文件</code>，消息写入就是简单的文件追加，文件可以在集群内复制备份以防丢失</li>
<li>  即使消息被消费，kafka 也不会立即删除该消息，可以通过配置使得过一段时间后自动删除以释放磁盘空间</li>
<li>  kafka依赖分布式协调服务Zookeeper，适合离线/在线信息的消费，与 storm 和 spark 等实时流式数据分析常常结合使用</li>
</ul>
<h2 id="kafka原理"><a href="#kafka原理" class="headerlink" title="kafka原理"></a>kafka原理</h2><h3 id="分布式和分区（distributed、partitioned）"><a href="#分布式和分区（distributed、partitioned）" class="headerlink" title="分布式和分区（distributed、partitioned）"></a>分布式和分区（distributed、partitioned）</h3><p>消息保存在 Topic 中，而为了能够实现大数据的存储，一个 topic 划分为多个分区，每个分区对应一个文件，可以分别存储到不同的机器上，以实现分布式的集群存储。另外，每个 partition 可以有一定的副本，备份到多台机器上，以提高可用性。<br>总结起来就是：一个 topic 对应的多个 partition 分散存储到集群中的多个 broker 上，存储方式是一个 partition 对应一个文件，每个 broker 负责存储在自己机器上的 partition 中的消息读写。</p>
<h3 id="副本（replicated-）"><a href="#副本（replicated-）" class="headerlink" title="副本（replicated ）"></a>副本（replicated ）</h3><p>这种冗余备份的方式在分布式系统中是很常见的，那么既然有副本，就涉及到对同一个文件的多个备份如何进行管理和调度。kafka 采取的方案是：每个 partition 选举一个 server 作为“leader”，由 leader 负责所有对该分区的读写，其他 server 作为 follower 只需要简单的与 leader 同步，保持跟进即可。如果原来的 leader 失效，会重新选举由其他的 follower 来成为新的 leader。</p>
<p>至于如何选取 leader，实际上如果我们了解 ZooKeeper，就会发现其实这正是 Zookeeper 所擅长的，Kafka 使用 ZK 在 Broker 中选出一个 Controller，用于 Partition 分配和 Leader 选举。</p>
<p>另外，这里我们可以看到，实际上作为 leader 的 server 承担了该分区所有的读写请求，因此其压力是比较大的，从整体考虑，有多少个 partition 就意味着会有多少个leader，kafka 会将 leader 分散到不同的 broker 上，确保整体的负载均衡。</p>
<p><img src="/2022/02/16/kafka%E7%AE%80%E4%BB%8B/image20220214195320.png" title="kafka数据流图"></p>
<h3 id="整体的数据流"><a href="#整体的数据流" class="headerlink" title="整体的数据流"></a>整体的数据流</h3><h4 id="数据的生产-produce"><a href="#数据的生产-produce" class="headerlink" title="数据的生产(produce)"></a>数据的生产(produce)</h4><p>对于生产者要写入的一条记录，可以指定四个参数：分别是 topic、partition、key 和 value，其中 topic 和 value（要写入的数据）是必须要指定的，而 key 和 partition 是可选的。</p>
<p>对于一条记录，先对其进行序列化，然后按照 Topic 和 Partition，放进对应的发送队列中。如果 Partition 没填，那么情况会是这样的：</p>
<ol>
<li>Key 有填。按照 Key 进行哈希，相同 Key 去一个 Partition。</li>
<li>Key 没填。Round-Robin 来选 Partition。</li>
</ol>
<p><img src="/2022/02/16/kafka%E7%AE%80%E4%BB%8B/image20220214195925.png" title="produce产生消息"></p>
<p>producer 将会和Topic下所有 partition leader 保持 socket 连接，消息由 producer 直接通过 socket 发送到 broker。其中 partition leader 的位置( host : port )注册在 zookeeper 中，producer 作为 zookeeper client<strong>，已经注册了 watch 用来监听 partition leader 的变更事件，</strong>因此，可以准确的知道谁是当前的 leader。<br>ps: zookeeper在分布式系统中真是不可或缺的组件</p>
<h4 id="数据消费过程-consume"><a href="#数据消费过程-consume" class="headerlink" title="数据消费过程(consume)"></a>数据消费过程(consume)</h4><p>对于消费者，不是以单独的形式存在的，每一个消费者属于一个 consumer group，一个 group 包含多个 consumer。特别需要注意的是：订阅 Topic 是以一个消费组来订阅的，发送到 Topic 的消息，只会被订阅此 Topic 的每个 group 中的一个 consumer 消费<br>具体说来，这实际上是根据 partition 来分的，一个 Partition，只能被消费组里的一个消费者消费，但是可以同时被多个消费组消费，消费组里的每个消费者是关联到一个 partition 的，因此有这样的说法：对于一个 topic,同一个 group 中不能有多于 partitions 个数的 consumer 同时消费,否则将意味着某些 consumer 将无法得到消息。<br>同一个消费组的两个消费者不会同时消费一个 partition。</p>
<p><img src="/2022/02/16/kafka%E7%AE%80%E4%BB%8B/image20220214201946.png" title="kafka消费"></p>
<p>在 kafka 中，采用了 pull 方式，即 consumer 在和 broker 建立连接之后，主动去 pull(或者说 fetch )消息，首先 consumer 端可以根据自己的消费能力适时的去 fetch 消息并处理，且可以控制消息消费的进度(offset)。</p>
<p>partition 中的消息只有一个 consumer 在消费，且不存在消息状态的控制，也没有复杂的消息确认机制，可见 kafka broker 端是相当轻量级的。当消息被 consumer 接收之后，需要保存 Offset 记录消费到哪，以前保存在 ZK 中，由于 ZK 的写性能不好，以前的解决方法都是 Consumer 每隔一分钟上报一次，在 0.10 版本后，Kafka 把这个 Offset 的保存，从 ZK 中剥离，<strong>保存在一个名叫 consumeroffsets topic 的 Topic 中</strong>，由此可见，consumer 客户端也很轻量级。</p>
<h3 id="消息传送机制"><a href="#消息传送机制" class="headerlink" title="消息传送机制"></a>消息传送机制</h3><p>Kafka 支持 3 种消息投递语义,在业务中，常常都是使用 At least once 的模型。</p>
<ul>
<li>  At most once：最多一次，消息可能会丢失，但不会重复。</li>
<li>  At least once：最少一次，消息不会丢失，可能会重复。</li>
<li>  Exactly once：只且一次，消息不丢失不重复，只且消费一次。</li>
</ul>
<h2 id="kafka集群框架"><a href="#kafka集群框架" class="headerlink" title="kafka集群框架"></a>kafka集群框架</h2><p><img src="/2022/02/16/kafka%E7%AE%80%E4%BB%8B/image20220214202757.png" title="kafka集群框架"></p>
<h2 id="kafka-API"><a href="#kafka-API" class="headerlink" title="kafka API"></a>kafka API</h2><p>ps: <strong>localhost:2181/kafka</strong>要增加zk的根目录<br><a href="https://www.jianshu.com/p/edf607eb0cb4">kafka各种配置参数</a></p>
<h3 id="启动zk和kafka"><a href="#启动zk和kafka" class="headerlink" title="启动zk和kafka"></a>启动zk和kafka</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 开启zk</span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line">// 开启kafka broker</span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>

<ul>
<li>config/server.properties<br>kafka配置文件,包含zk信息等</li>
</ul>
<h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><p><strong>创建 <code>Kafka</code> 主题</strong> - <code>Kafka</code> 提供了一个名为 <code>kafka-topics.sh</code> 的命令行实用程序，用于在服务器上创建主题。 打开新终端并键入以下示例。</p>
<ul>
<li>语法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181/kafka --replication-factor 1 --partitions 1 --topic topic-name</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181/kafka --replication-factor 1 --partitions 1 --topic Hello-Kafka</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="主题列表"><a href="#主题列表" class="headerlink" title="主题列表"></a>主题列表</h3><ul>
<li>语法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 查看kafka服务器中的主题列表</span><br><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181/kafka</span><br></pre></td></tr></table></figure></li>
<li>输出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello-Kafka</span><br><span class="line">__consumer_offsets</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="生产者发送消息"><a href="#生产者发送消息" class="headerlink" title="生产者发送消息"></a>生产者发送消息</h3><ul>
<li>语法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</span><br></pre></td></tr></table></figure>
生产者将等待来自 <code>stdin</code> 的输入并发布到 <code>Kafka</code> 集群。</li>
<li>输入<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">nihao</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hello my love</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启动消费者接受消息"><a href="#启动消费者接受消息" class="headerlink" title="启动消费者接受消息"></a>启动消费者接受消息</h3><ul>
<li>语法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic topic-name --from-beginning</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>ps:新版本的kafka已经不支持该命令了</strong></p>
<ul>
<li>新语法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic Hello-Kafka --from-beginning</span><br></pre></td></tr></table></figure></li>
<li>输出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[tdsql@TENCENT64 /data/application/kafka]$ bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic Hello-Kafka --from-beginning</span><br><span class="line">nihao</span><br><span class="line">hello my love</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改主题topic"><a href="#修改主题topic" class="headerlink" title="修改主题topic"></a>修改主题topic</h3><ul>
<li>语法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh </span><br><span class="line">—zookeeper localhost:2181 </span><br><span class="line">--alter </span><br><span class="line">--topic topic_name </span><br><span class="line">--partitions count</span><br></pre></td></tr></table></figure></li>
<li>示例1<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh </span><br><span class="line">--zookeeper localhost:2181/kafka</span><br><span class="line">--alter </span><br><span class="line">--topic Hello-kafka </span><br><span class="line">--partitions 2</span><br></pre></td></tr></table></figure></li>
<li>示例2<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper 192.168.162.52:2181,192.168.162.235:2181,192.168.162.239:2181 --alter --topic test0 --config max.message.bytes=128000</span><br><span class="line">bin/kafka-topics.sh --zookeeper 192.168.162.52:2181,192.168.162.235:2181,192.168.162.239:2181 --alter --topic test0 --delete-config max.message.bytes</span><br><span class="line">bin/kafka-topics.sh --zookeeper 192.168.162.52:2181,192.168.162.235:2181,192.168.162.239:2181 --alter --topic test0 --partitions 10 </span><br><span class="line">bin/kafka-topics.sh --zookeeper 192.168.162.52:2181,192.168.162.235:2181,192.168.162.239:2181 --alter --topic test0 --partitions 3 ## Kafka分区数量只允许增加，不允许减少</span><br></pre></td></tr></table></figure></li>
<li>输出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[tdsql@TENCENT64 /data/application/kafka]$ bin/kafka-topics.sh --zookeeper localhost:2181/kafka --alter --topic Hello-Kafka --partitions 2</span><br><span class="line">WARNING: If partitions are increased for a topic that has a key, the partition logic or ordering of the messages will be affected</span><br><span class="line">Adding partitions succeeded!</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除主题top"><a href="#删除主题top" class="headerlink" title="删除主题top"></a>删除主题top</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认情况下Kafka的Topic不能直接删除的，需要进行相关参数配置</span><br><span class="line">bin/kafka-topics.sh --delete --topic test0 --zookeeper 192.168.187.146:2181</span><br><span class="line"></span><br><span class="line">默认情况下，删除是标记删除，没有实际删除这个Topic；如果运行删除Topic，可以通过如下两种方式：</span><br><span class="line">方式一：通过delete命令删除后，手动将本地磁盘以及zk上的相关topic的信息删除即可</span><br><span class="line">方式二：配置server.properties文件，给定参数delete.topic.enable=true，重启kafka服务，此时执行delete命令表示允许进行Topic的删除</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源组件学习</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的错误类型</title>
    <url>/2022/02/14/golang%E7%9A%84%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<p>作为golang语言的初心者，很多go的常用接口熟悉结构体都需要仔细看看源码，避免踩坑。目前重构代码用到了自己写的错误类和wrap相关函数对基层错误进行包装和unwrap函数对错误类进行递归拆解，但是写起来就是很不美观，强迫症。学习下优雅的处理错误吧。</p>
<span id="more"></span>
<!-- toc -->

<p>[toc]</p>
<h2 id="golang的错误类型error"><a href="#golang的错误类型error" class="headerlink" title="golang的错误类型error"></a>golang的错误类型<strong>error</strong></h2><p><strong>Golang</strong> 中的错误也是一种类型。错误用内置的 <code>error</code> 类型表示。就像其他类型，如 <code>int</code>，<code>float64</code> 等。</p>
<p>错误值可以存储在变量中，也可以从函数中返回，等等。</p>
<h2 id="error类型源码"><a href="#error类型源码" class="headerlink" title="error类型源码"></a>error类型源码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/builtin/builtin.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>error</code> 是一个接口类型，它包含一个 <code>Error()</code> 方法，返回值为 <code>string</code>。任何实现这个接口的类型都可以作为一个错误使用，Error 这个方法提供了对错误的描述。<br>ps: <code>nil</code>代表没有错误</p>
<ul>
<li>实例<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;/test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;file is ：&quot;</span>, f)</span><br></pre></td></tr></table></figure>
当执行打印错误语句时，fmt 包会自动调用 <code>err.Error()</code> 函数来打印字符串。</li>
</ul>
<h2 id="error的创建"><a href="#error的创建" class="headerlink" title="error的创建"></a>error的创建</h2><p>创建方式有两种</p>
<ul>
<li>  errors.New()</li>
<li>  fmt.Errorf()</li>
</ul>
<h3 id="errors-New-函数-errorString类型"><a href="#errors-New-函数-errorString类型" class="headerlink" title="errors.New()函数 - errorString类型"></a>errors.New()函数 - errorString类型</h3><ul>
<li>src/errors/errors.go</li>
<li>源码<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/errors/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
New () 函数返回一个错误，该错误的格式为给定的文本。<br>即使文本相同，每次对 New 的调用也会返回一个不同的错误值。</li>
</ul>
<p>其中 errorString 是一个结构体，只有一个 string 类型的字段 s，并且实现了唯一的方法：Error()</p>
<ul>
<li>例子<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.errors.New() 创建一个 error</span></span><br><span class="line">err1 := errors.New(<span class="string">&quot;这是 errors.New() 创建的错误&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1 错误类型：%T，错误为：%v\n&quot;</span>, err1, err1)</span><br><span class="line">err1 错误类型：*errors.errorString，错误为：这是 errors.New() 创建的错误</span><br></pre></td></tr></table></figure>
可以看到，错误类型是 <code>errorString</code> 指针，前面的 <code>errors.</code> 表明了其在 errors 包下。</li>
</ul>
<h3 id="fmt-Errorf-函数-errorString类型和wrapError类型"><a href="#fmt-Errorf-函数-errorString类型和wrapError类型" class="headerlink" title="fmt.Errorf()函数 - errorString类型和wrapError类型"></a>fmt.Errorf()函数 - errorString类型和wrapError类型</h3><ul>
<li><p>源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/fmt/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p := newPrinter()</span><br><span class="line">    p.wrapErrs = <span class="literal">true</span></span><br><span class="line">    p.doPrintf(format, a)</span><br><span class="line">    s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> p.wrappedErr == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = errors.New(s)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = &amp;wrapError&#123;s, p.wrappedErr&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.free()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看到，<code>p.wrappedErr</code> 为 <code>nil</code> 的时候，会调用 <code>errors.New()</code> 来创建错误。<br>所以fmt.Errorf()函数创建的错误类型也为<code>errors.errorString</code></p>
</li>
<li><p>例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.fmt.Errorf()</span></span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;这个 fmt.Errorf() 创建的错误,错误编码为：%d&quot;</span>, <span class="number">404</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2 错误类型：%T，错误为：%v\n&quot;</span>, err2, err2)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">err2 错误类型：*errors.errorString，错误为：这个 fmt.Errorf() 创建的错误,错误编码为：<span class="number">404</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="fmt-wrapError"><a href="#fmt-wrapError" class="headerlink" title="fmt.wrapError"></a>fmt.wrapError</h4><ul>
<li>例子<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. go 1.13 新增加的错误处理特性  %w</span></span><br><span class="line">err3 := fmt.Errorf(<span class="string">&quot;err3: %w&quot;</span>, err2)  <span class="comment">// err3包裹err2错误</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;err3 错误类型：%T，错误为：%v\n&quot;</span>, err3, err3)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">err3 错误类型：*fmt.wrapError，错误为：err3: 这个 fmt.Errorf() 创建的错误,错误编码为：<span class="number">404</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="newPrinter结构体"><a href="#newPrinter结构体" class="headerlink" title="newPrinter结构体"></a>newPrinter结构体</h4><ul>
<li>源码<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/fmt/print.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// newPrinter allocates a new pp struct or grabs a cached one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span> *<span class="title">pp</span></span> &#123;</span><br><span class="line">    p := ppFree.Get().(*pp)</span><br><span class="line">    p.panicking = <span class="literal">false</span></span><br><span class="line">    p.erroring = <span class="literal">false</span></span><br><span class="line">    p.wrapErrs = <span class="literal">false</span></span><br><span class="line">    p.fmt.init(&amp;p.buf)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// src/fmt/print.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pp is used to store a printer&#x27;s state and is reused with sync.Pool to avoid allocations.</span></span><br><span class="line"><span class="keyword">type</span> pp <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// wrapErrs is set when the format string may contain a %w verb.</span></span><br><span class="line">    wrapErrs <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrappedErr records the target of the %w verb.</span></span><br><span class="line">    wrappedErr error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>newPrinter()</code>生成一个pp结构体，pp结构体有wrapErrs和wrappedErr两个成员。</li>
<li><code>wrapErrs</code><ul>
<li>bool 类型，当格式字符串包含<code>％w</code> 动词时，将赋值为 true</li>
</ul>
</li>
<li><code>wrappedErr</code><ul>
<li>error 类型，记录<code>％w</code> 动词的目标，即例子的 <code>err2</code></li>
</ul>
</li>
</ul>
<p>在函数fmt.Errorf()中<code>p.wrappedErr</code>不为空则会调用生成一个<code>wrapErrors</code>结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = &amp;wrapError&#123;s, p.wrappedErr&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fmt-wrapError分析"><a href="#fmt-wrapError分析" class="headerlink" title="fmt.wrapError分析"></a>fmt.wrapError分析</h3><ul>
<li>源码<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/fmt/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg <span class="keyword">string</span></span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>msg, <code>string</code>类型</li>
<li>err <code>error</code>类型</li>
</ul>
<p>实现了两个方法：</p>
<p>Error ()，也说明 wrapError 结构体实现了 error 接口，是一个 error 类型<br>Unwrap ()，作用是返回原错误值，没有自定义的 msg 了。也就是说拆开了一个被包装的 error。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧，Golang 中创建错误有两种方式：<br>第一种：errors.New() 函数，其返回值类型为 *errors.errorString。</p>
<p>第二种：fmt.Errorf() 函数<br>当使用 fmt.Errorf() 来创建错误时，核心有以下两点：</p>
<p>错误描述中不包含 %w 时，p.wrappedErr 为 nil，所以底层也是调用 errors.New() 创建错误。因此错误类型就是 *errors.errorString。</p>
<p>错误描述中包含%w 时，p.wrappedErr 不为 nil，所以底层实例化 wrapError 结构体指针。 因此错误类型是 *fmt.wrapError，可以理解为包裹错误类型。</p>
]]></content>
      <categories>
        <category>语言学习</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>libevent库学习笔记</title>
    <url>/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<p>libevent是一个C语言编写的轻量级的跨平台的高性能网络库，它基于事件驱动的Reactor模式，支持多种I/O复用技术，目前已被广泛使用。了解其原理、研究其源码是非常有意义和价值的，本文首先介绍几种常见的I/O模型，由此引出libevent并剖析其源码,希望能和读者一起提升网络相关的技能。</p>
<span id="more"></span>
<!-- toc -->
<p>[toc]</p>
<p><a href="https://aceld.gitbooks.io/libevent/content/">参考文章</a></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪(也就是说输入已准备好，或者描述符已经承接更多的输出)，它就通知进程，这种能力称为I/O复用。IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。<code>多路是指网络连接，复用指的是同一个线程</code>。</p>
<h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为<code>内核空间</code>，一部分为<code>用户空间</code>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间，如图2所示。这里还有一个比较重要的概念，叫DMA（Direct Memory Access直接存储器访问），它的作用是处理各种I/O，包括网络I/O和磁盘I/O。CPU是不会直接处理I/O的，这是因为CPU非常宝贵，而I/O是比较耗时的，如果CPU一直等待某一次I/O事件完成，会带来极大的浪费，且性能会急剧下降，因此<code>需要一种机制能够完成I/O，并通知CPU，DMA即是这个角色。</code></p>
<img src="image-20220107155339868.png" alt="用户态和内核态" style="zoom: 25%;" />



<ol>
<li>等待数据准备</li>
<li>将数据从内核空间拷贝到进程中</li>
</ol>
<h3 id="Linux两大类网络模型"><a href="#Linux两大类网络模型" class="headerlink" title="Linux两大类网络模型"></a>Linux两大类网络模型</h3><ul>
<li>同步I/O</li>
</ul>
<blockquote>
<blockquote>
<p>阻塞I/O</p>
<p>非阻塞I/O</p>
<p>I/O多路复用</p>
<p>信号驱动I/O</p>
</blockquote>
</blockquote>
<ul>
<li>异步I/O</li>
</ul>
<p>同步I/O和异步I/O主要区别在于： 用户进程在发起I/O操作之后可以立刻去做其他事情，数据拷贝由硬件拷贝到内核空间、从内核空间拷贝到用户空间都不阻塞，这种就是异步I/O；两个步骤中有任何一步发生阻塞，就是同步I/O。</p>
<h2 id="I-O多路复用-1"><a href="#I-O多路复用-1" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set * readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  fd_set * writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数介绍</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nfds</td>
<td align="left">int</td>
<td align="left">文件描述符最大值+1</td>
</tr>
<tr>
<td align="left">readfds</td>
<td align="left">fd_set *</td>
<td align="left">读事件文件描述符集合</td>
</tr>
<tr>
<td align="left">writefds</td>
<td align="left">fd_set *</td>
<td align="left">写事件文件描述符集合</td>
</tr>
<tr>
<td align="left">exceptfds</td>
<td align="left">fd_set *</td>
<td align="left">异常事件文件描述符集合</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">timeval *</td>
<td align="left">超时时间，超过该时间即使没有事件到达，select也会返回，避免无休止地等待</td>
</tr>
</tbody></table>
</li>
<li><p>read事件代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">2000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  <span class="built_in">bind</span>(sockfd,(struct sockaddr*)&amp;addr ,<span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line">  <span class="built_in">listen</span> (sockfd, <span class="number">5</span>); </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (client));</span><br><span class="line">    addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">    fds[i] = <span class="built_in">accept</span>(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">    	max = fds[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ####################################################################</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;rset);     <span class="comment">// 1. 初始化/重置rset</span></span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  		<span class="built_in">FD_SET</span>(fds[i],&amp;rset); <span class="comment">// 2. 为rset赋值</span></span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 传入最大描述符数量加1</span></span><br><span class="line">	<span class="built_in">select</span>(max+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 3. select阻塞</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fds[i], &amp;rset))&#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(fds[i], buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>select 底层机制<br>内核会将传入的rset由用户态拷贝到内核态，然后在内核中判断每一个置位的rset是否有数据到达（将rset拷贝到内核态是因为在内核中判断是否有数据到达比在用户态判断效率高很多），如果有，则标记这一位，如果没有，继续往后判断，除非到达select的超时时间，所以select是一个阻塞的函数。select函数中第一个参数nfds有什么用呢？select在对rset遍历时，会截取0~nfds，因为大于nfds是不会有文件描述符的；当select函数返回时，循环遍历这5个文件描述符，然后检测每一个文件描述符是否被标记，如果标记了，说明有read事件发生，则读取缓存中的数据。这里需要注意某一个文件描述符是否有数据是随机的，可能有多个文件描述符同时有数据到达，因此需要执行for遍历每一个文件描述符。</p>
</li>
</ul>
<ul>
<li>select存在的问题</li>
</ul>
<ol>
<li>len(rset)=1024,所以最多只能监听1024个文件描述符。这个是操作系统进行的限制，虽然可以更改，但是有上限；</li>
<li>rset不可重用。从代码中可以看到，每次循环时，都需要调用FD_ZERO(&amp;rest)，重置rset，这是因为内核检测是否有数据时会更改rset，如果不重置，上一次select返回的结果会对下一次内核判断某一个文件描述符是否有数据产生影响；</li>
<li>解除select阻塞后需遍历每一个fd。这是因为内核判断是否有数据后会直接返回，但是并没有返回究竟是哪一个文件描述符有数据。</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line">      <span class="keyword">short</span> events;  <span class="comment">// 用户感兴趣的事件</span></span><br><span class="line">      <span class="keyword">short</span> revents; <span class="comment">// 系统触发的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>参数介绍</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fds</td>
<td align="left">pollfd *</td>
<td align="left">文件描述符数组，和select不同，fds中每一个元素不是一个数字，而是pollfd类型</td>
</tr>
<tr>
<td align="left">nfds</td>
<td align="left">unsigned int</td>
<td align="left">监听的文件描述符数量</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">int</td>
<td align="left">超时时间，含义和select中timeout类似</td>
</tr>
</tbody></table>
</li>
<li><p>poll使用代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (client));</span><br><span class="line">    addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">    pollfds[i].fd = <span class="built_in">accept</span>(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// ######################################################################</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">poll</span>(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">			pollfds[i].revents = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(pollfds[i].fd, buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>poll原理<br>poll的原理和select非常类似，也是将pollfds拷贝到内核空间。不同的是，当内核判断某个pollfd有数据时，会将pollfd.revents置位，然后解除poll的阻塞。因此，<code>for中遍历每一个pollfd先检测该文件描述符是否被置位</code>，如果是说明有数据，则将置位的revents恢复成默认，随后读取该数据。</p>
</li>
<li><p>poll存在的问题<br>poll解决了select中rset无法重用的问题，通过自定义的pollfd结构，巧妙地完成了”置位-恢复”的操作；而且，poll中文件描述符不是一个数字而是pollfd结构，可以监听更多的文件描述符，也就<code>突破了select中len(rst)=1024的限制</code>，<br>但是也存在一个问题：poll解除阻塞后依旧需要循环遍历所有的pollfds，然后才知道具体哪一个文件描述符有数据</p>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll在poll的基础上，通过双向链表的结构，解决了poll中存在的问题，接下来看epoll的具体实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[4];</span></span><br><span class="line">  <span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (client));</span><br><span class="line">    addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">    ev.data.fd = <span class="built_in">accept</span>(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ###################################</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">  	nfds = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">4</span>, <span class="number">10000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(events[i].data.fd, buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>epoll的三个主要函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>); <span class="comment">// 这里的参数10没有什么意义，事实上，通过源码可以知道这里只要传入一个正数就OK</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line">nfds = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">4</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三个函数对应的步骤:</p>
</blockquote>
</li>
</ul>
<ol>
<li>生成epoll面板epfd（epoll_create函数的功能，对应图5中的橙黄色部分）</li>
<li>在 epfd中将文件描述符和事件绑定（epoll_ctl函数的功能，对应图中的fd[x]–&gt;events）</li>
<li>阻塞并监听文件描述符（epoll_wait函数的功能）</li>
</ol>
<img src="image-20220110102301197.png" alt="" style="zoom:60%;"  />


<p>内核空间部分是如何处理的，当某一个文件描述符有数据到达时，内核空间会将该文件描述符调整到最前面，且nfds+1，对应图中绿色部分，表示fd3和fd2有数据，此时nfds=2，解除epoll_wait函数的阻塞并返回nfds的值。在for进行遍历时，只需要遍历0~nfds即可，也就解决了select和poll中需要遍历整个文件描述符数组的问题。</p>
<ul>
<li>epoll的触发机制</li>
</ul>
<ol>
<li>边缘触发（edge triggered ET）<blockquote>
<p>对于边缘触发，<code>epoll_wait()只返回一次</code>，即只在该读写事件发生时返回，也就是说如果事件处理函数只读取了该文件描述缓冲区的部分内容时返回，再次调用epoll_wait()，虽然此时该描述符对应缓冲区中还有数据，但epoll_wait()函数不会返回。</p>
</blockquote>
</li>
<li>水平触发（level triggered LT）<blockquote>
<p>对于水平触发，它不管是否有事件反生，只要文件描述符对应的缓冲区中有数据可读写，epoll_wait()就会返回。</p>
</blockquote>
</li>
</ol>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>本节将介绍Reactor模式，它是libevent的核心，因此有必要对其进行介绍，有了上文中select、poll、epoll的基础，Reactor模式就比较好理解了。 Reactor释义”反应堆”（中文翻译的名称和它的功能几乎没有什么联系，因此下文还是采用英文名），Reactor模式的是一种基于事件驱动的异步回调机制。一般的函数调用是压栈式调用，函数之间调用需要同步等待，而Reactor模式不同，应用程序提供相应的接口并注册到Reactor上，<code>如果相应的事件发生，Reactor将主动调用应用程序注册的接口（也就是回调函数）</code>。所以，上文中的select、poll、epoll其实都是Reactor模式。</p>
<img src="image-20220110151551749.png" alt="" style="zoom:50%;" />

<ul>
<li>代码框架<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">register_handler</span><span class="params">(Event_Handler *pHandler, <span class="keyword">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove_handler</span><span class="params">(Event_Handler *pHeadler, <span class="keyword">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(timeval *ptv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event_Handler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// events maybe read/write/tiomeout .etc</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> events)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HANDLE <span class="title">get_handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Reactor组件</li>
</ul>
<ol>
<li>事件源(图中的handle)<blockquote>
<p>在linux系统中是文件描述符，在window上是socket或Handle，下文统称为”句柄”</p>
</blockquote>
</li>
<li>事件多路分发机制(图中的Event Demultiplexer)<blockquote>
<p>由操作系统提供的I/O多路分发机制，比如上文所述的select、poll、epoll</p>
</blockquote>
</li>
<li>反应器(图中的Reactor)<blockquote>
<p>Reactor模式中的事件管理接口，提供注册、注销事件和事件循环，它的声明参见代码中的class Reactor</p>
</blockquote>
</li>
<li>事件处理程序(图中的Event_Handler和Concrete_Event_Handler)<blockquote>
<p>包括抽象处理程序和具体处理程序，主要是考虑扩展性，它的声明参见class Event_Handler</p>
</blockquote>
</li>
</ol>
<h2 id="Libevent"><a href="#Libevent" class="headerlink" title="Libevent"></a>Libevent</h2><h3 id="libevent定时器实现"><a href="#libevent定时器实现" class="headerlink" title="libevent定时器实现"></a>libevent定时器实现</h3><ul>
<li>代码实例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time_cb</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timer wakeup\n&quot;</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv); <span class="comment">// reschedule timer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化libevent,相当于初始化Reactor实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> <span class="built_in">event_init</span>();</span><br><span class="line">    tv.tv_sec = <span class="number">10</span>; <span class="comment">// 10s period</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define evtimer_set(ev, cb, arg)	event_set(ev, -1, 0, cb, arg)</span></span><br><span class="line">    <span class="comment">// evtimer_set 也是event_set</span></span><br><span class="line">    <span class="comment">// 2. 初始化时间event,设置回调函数和关注的事件</span></span><br><span class="line">    <span class="built_in">evtimer_set</span>(&amp;ev, time_cb, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置event从属的event_base</span></span><br><span class="line">    <span class="built_in">event_base_set</span>(base, &amp;ev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 正式添加事件</span></span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 等待事件就绪,阻塞</span></span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="libevent源码分析"><a href="#libevent源码分析" class="headerlink" title="libevent源码分析"></a>libevent源码分析</h3><p>事件event结构</p>
<img src="image-20220110154957576.png" alt="" style="zoom:40%;" />
- 双向链表事件（使用双向链表结构保存了event的所有事件）
-- event_next（保存所有已注册的I/O事件）
-- ev_signal_next（保存所有已注册的信号事件）
-- ev_active_next（保存所有已激活的事件，激活的含义就是文件描述符有数据）
- ev_base（该事件所属的Reactor实例，是一个event_base的指针，关于event_base，后面将详细介绍）
- ev_events（它是event关注的事件类型，有多种取值，且可以"|"组合，比如"EV_ERAD|EV_PERSIST",当然，定时器事件不能和I/O事件组合在一起，可以考虑下这是为什么）

<img src="image-20220110155617337.png" alt="" style="zoom:50%;" />
libevent事件管理的结构，左侧红色部分表示I/O事件和signal的结构，它们都是由若干事件组成的双向链表，图中把它们画在一起是因为它们结构相同，但实际上它们是两个双向链表；中间蓝色部分表示时间事件，时间事件在底层是一个以超时时间为key的小根堆，由于libevent需要频繁获取最近的时间事件，因此采用小根堆存储，小根堆在底层是用数组实现的；右边绿色部分表示激活事件的结构，它的底层也是双向链表，但它与I/O事件的双向链表不同，它是根据事件的priority进行排序的，优先级高的在前面，优先被执行。因此，有可能出现优先级比较低的事件一直得不到执行。libevent提供了设置事件优先级的api，如果不设置，会给一个默认的优先级。



<h3 id="事件接口函数"><a href="#事件接口函数" class="headerlink" title="事件接口函数"></a>事件接口函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件设置接口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> fd, <span class="keyword">short</span> events,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> (*callback)(<span class="keyword">int</span>,<span class="keyword">short</span>,<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// fd:事件ev绑定的文件描述符或信号,如果是超时事件,fd=-1</span></span></span><br><span class="line"><span class="function"><span class="comment">// events:设置事件的类型 EV_READ|EV_PERSIST, EV_WRITE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_set</span><span class="params">(struct event_base *base, struct event *ev)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置event的ev到event_base上</span></span></span><br><span class="line"><span class="function"><span class="comment">// libevent 有一个全局的event_base指针,</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用该函数可以将ev注册到自定义的event_base上</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> pri)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置ev的优先级</span></span></span><br></pre></td></tr></table></figure>

<h3 id="事件处理框架"><a href="#事件处理框架" class="headerlink" title="事件处理框架"></a>事件处理框架</h3><ul>
<li>event_base框架</li>
</ul>
<img src="image-20220110160543388.png" alt="" style="zoom:20%;" />
- 核心变量
> 核心变量包括evsel和evbase。添加事件的调用关系为evsel->add(evbase, ev)，evsel只负责调用，将具体的事件ev注册到evbase中。
- 事件指针
> 主要包括activequeues和event_queue，分别保存带有优先级的激活事件和所有注册时间的event指针。activequeues[priority]是一个链表，链表中的每个节点指向一个优先级为priority的激活事件event。
- 时间管理变量
> 包括时间缓存tv_cache和event_tv，下文会继续介绍
- 其他变量
> 主要是各个结构数量的统计变量，比如event_count是注册事件的总和，nactivequeues是激活事件的总量。

<h3 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h3><p>libevent提供的对于事件的注册、注销以及当事件处于激活状态时调用回到接口的api如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> loops)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *event, <span class="keyword">int</span> res, <span class="keyword">short</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>event_add 函数介绍:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ev:指向要注册的事件;tv:超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> ev-&gt;base;</span><br><span class="line">    <span class="comment">// event_base使用的系统IO策略</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> =</span> base-&gt;evsel; </span><br><span class="line">    <span class="keyword">void</span> *evbase = base-&gt;evbase;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新的timer事件，在小根堆上预留一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (tv != <span class="literal">NULL</span> &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min_heap_reserve</span>(&amp;base-&gt;timeheap,</span><br><span class="line">			<span class="number">1</span> + <span class="built_in">min_heap_size</span>(&amp;base-&gt;timeheap)) == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> (<span class="number">-1</span>);  <span class="comment">/* ENOMEM == errno */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_SIGNAL)) &amp;&amp;</span><br><span class="line">	    !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE))) &#123;</span><br><span class="line">		res = evsel-&gt;<span class="built_in">add</span>(evbase, ev);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="comment">// 如果事件添加成功则插入到eventqueue中</span></span><br><span class="line">			<span class="built_in">event_queue_insert</span>(base, ev, EVLIST_INSERTED);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; tv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">		<span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT) <span class="comment">// EVLIST_TIMEOUT表示该事件已经存在与定时器堆中，则删除旧的</span></span><br><span class="line">			<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">			</span><br><span class="line">        <span class="built_in">gettime</span>(base, &amp;now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;</span><br><span class="line">		    (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123; <span class="comment">// 如果事件已经就绪则从激活链表中删除</span></span><br><span class="line">			<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_ACTIVE);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 插入定时器事件</span></span><br><span class="line">        <span class="built_in">event_queue_insert</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环是libevent非常重要的一部分，它的主要职责就是阻塞等待事件到来并调用事件绑定的回到函数。</p>
<ul>
<li>事件循环的逻辑结构</li>
</ul>
<img src="image-20220110162619843.png" alt="" style="zoom:26%;" />
* 事件循环实现
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> =</span> base-&gt;evsel;</span><br><span class="line"><span class="keyword">void</span> *evbase = base-&gt;evbase;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line"><span class="keyword">int</span> res, done;</span><br><span class="line"><span class="comment">// 清空时间缓存</span></span><br><span class="line">base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例</span></span><br><span class="line"><span class="keyword">if</span> (base-&gt;sig.ev_signal_added)</span><br><span class="line">	evsignal_base = base;</span><br><span class="line">done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!done) &#123; <span class="comment">// 事件主循环</span></span><br><span class="line">	<span class="comment">// 校正系统时间</span></span><br><span class="line">	<span class="built_in">timeout_correct</span>(base, &amp;tv);</span><br><span class="line">	<span class="comment">// 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间</span></span><br><span class="line">	tv_p = &amp;tv;</span><br><span class="line">	<span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class="line">		<span class="built_in">timeout_next</span>(base, &amp;tv_p);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 依然有未处理的就绪时间，就让I/O demultiplexer立即返回，不必等待</span></span><br><span class="line">			<span class="comment">// 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理</span></span><br><span class="line">			<span class="built_in">evutil_timerclear</span>(&amp;tv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前没有注册事件，就退出</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">event_haveevents</span>(base)) &#123;</span><br><span class="line">		<span class="built_in">event_debug</span>((<span class="string">&quot;%s: no events registered.&quot;</span>, __func__));</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新last wait time，并清空time cache</span></span><br><span class="line">	<span class="built_in">gettime</span>(base, &amp;base-&gt;event_tv);</span><br><span class="line">	base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；</span></span><br><span class="line">	<span class="comment">// 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中</span></span><br><span class="line">	res = evsel-&gt;<span class="built_in">dispatch</span>(base, evbase, tv_p);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 将time cache赋值为当前系统时间</span></span><br><span class="line">	<span class="built_in">gettime</span>(base, &amp;base-&gt;tv_cache);</span><br><span class="line">	<span class="comment">// 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中</span></span><br><span class="line">	<span class="built_in">timeout_process</span>(base);</span><br><span class="line">	<span class="comment">// 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理</span></span><br><span class="line">	<span class="comment">// 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，</span></span><br><span class="line">	<span class="comment">// 然后处理链表中的所有就绪事件；</span></span><br><span class="line">	<span class="comment">// 因此低优先级的就绪事件可能得不到及时处理；</span></span><br><span class="line">	<span class="keyword">if</span> (base-&gt;event_count_active) &#123;</span><br><span class="line">		<span class="built_in">event_process_active</span>(base);</span><br><span class="line">		<span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; (flags &amp; EVLOOP_ONCE))</span><br><span class="line">			done = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; EVLOOP_NONBLOCK)</span><br><span class="line">		done = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束，清空时间缓存</span></span><br><span class="line">base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">event_debug</span>((<span class="string">&quot;%s: asked to terminate loop.&quot;</span>, __func__));</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>libevent函数的一大亮点就是将I/O和timer事件统一起来了，这里就有个疑问，为什么将IO事件的timeout设置为所有定时器事件的最小时间，就能将timer事件完美融合到系统IO机制中？原因是timer事件主要目标是定时器到期后需要触发一个回调，IO机制是已经激活的event才会触发回调函数，所以，只要有一种机制可以将到期的timer放到激活链表中就可以。libevent将IO事件的timeout设置为定时器事件的最小时间，那么当IO事件激活时，从timer堆中取出最小的timer判断是否到期，如果到期将其也放入激活链表中；如果IO时间在timeout内没有激活,则会触发超时，此时也检查最小的timer是否到期，这样就能将timer事件很好地放到激活事件中。也就实现了将I/O和timer事件统一起来。</p>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>linux条件变量pthread_cond_wait</title>
    <url>/2022/01/21/linux%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fpthread-cond-wait/</url>
    <content><![CDATA[<hr>
<p>linux条件变量的使用，以及为什么pthread_cond_wait要传入一个互斥量，并且要解锁互斥量，再wait。通过一个常用的pthread_cond_wait使用方法来讲解。c++11的条件变量也是同理使用。</p>
<span id="more"></span>
<!-- toc -->

<h2 id="linux条件变量pthread-cond-wait理解"><a href="#linux条件变量pthread-cond-wait理解" class="headerlink" title="linux条件变量pthread_cond_wait理解"></a>linux条件变量pthread_cond_wait理解</h2><ul>
<li><p>正确的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程A，条件测试</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(mtx);        <span class="comment">// a1</span></span><br><span class="line"><span class="keyword">while</span>(pass == <span class="number">0</span>) &#123;              <span class="comment">// a2 </span></span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(cv, mtx); <span class="comment">// a3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(mtx);      <span class="comment">// a4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B，条件发生修改，对应的signal代码</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(mtx);   <span class="comment">// b1</span></span><br><span class="line">pass = <span class="number">1</span>;                  <span class="comment">// b2</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(mtx); <span class="comment">// b3</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(cv);   <span class="comment">// b4</span></span><br></pre></td></tr></table></figure></li>
<li><p>步骤拆解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程A，条件测试</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(mtx);        <span class="comment">// a1</span></span><br><span class="line"><span class="keyword">while</span>(pass == <span class="number">0</span>) &#123;              <span class="comment">// a2 </span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(mtx);  <span class="comment">// a3</span></span><br><span class="line">    <span class="built_in">pthread_cond_just_wait</span>(cv); <span class="comment">// a4</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(mtx);    <span class="comment">// a5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(mtx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B，条件发生修改，对应的signal代码</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(mtx);   <span class="comment">// b1</span></span><br><span class="line">pass = <span class="number">1</span>;                  <span class="comment">// b2</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(mtx); <span class="comment">// b3</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(cv);   <span class="comment">// b4</span></span><br></pre></td></tr></table></figure>
<p>存在问题，若步骤是a1，a2，a3，b1，b2，b3，b4，a5<br>这样的话，线程a是不会被唤醒的。因此pthread_cond_wait是必须是一个原子性操作。</p>
</li>
<li><p>条件变量传入的互斥锁<br>这个互斥锁，不是用来保护条件变量的内部状态。而是用来保护外部”条件”(就是那个 while 循环中的判断）。假如条件变量的内部状态需要锁定，完全可以在内部实现中维护一个锁，没有必要从外部传进来。<br>用于判断是否等待的“条件“，通常就是线程之间共享的某个变量值。A 线程判断”条件“等待，会读取共享变量。B 线程让”条件“满足，会修改变量。<code>这个锁，就是保护线程间的共享变量（”条件“）</code>，让”条件“不会一边修改，一边读取。这把锁还有个额外的作用。wait 函数会阻塞，将线程 A 放到阻塞队列中。wait 函数放在锁的 lock，unlock 内部，也保证了线程还没有真正放到阻塞队列时，线程 B 不能修改“条件”后进行唤醒。这段话应该暂时读不懂，可回头再看，先放在这里，不然描述就不够准确。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>libgo源码阅读</title>
    <url>/2022/02/10/libgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<hr>
<p>目前工作上需要降原先的线程改为协程框架，来解决业务上请求量大和某些接口请求时间长的问题。因此，慢慢阅读下源码，避免后续踩坑。</p>
<span id="more"></span>
<!-- toc -->

<p>[toc]</p>
<h2 id="协程最主要的事情"><a href="#协程最主要的事情" class="headerlink" title="协程最主要的事情"></a>协程最主要的事情</h2><ul>
<li>实现上下文切换</li>
<li>系统函数hook</li>
<li>协程调度</li>
<li>时间管理</li>
</ul>
<h3 id="libgo目录结构"><a href="#libgo目录结构" class="headerlink" title="libgo目录结构"></a>libgo目录结构</h3><ul>
<li>task：协程的相关实现；</li>
<li>scheduler：协程调度的实现；</li>
<li>debug：libgo 自带的调试功能（用于协程状态的定位等）；</li>
<li>coroutine.h：对一些常用对方法进行了重定义。</li>
<li>netio：hook的系统调用；</li>
<li>context：上下文的切换；</li>
<li>pool：libgo 实现的连接池</li>
</ul>
<h2 id="libgo的三大结构体"><a href="#libgo的三大结构体" class="headerlink" title="libgo的三大结构体"></a>libgo的三大结构体</h2><ul>
<li>调度器(Scheduler)</li>
<li>执行器(Processer)</li>
<li>协程(Task)    </li>
</ul>
<p><img src="/2022/02/10/libgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/20220209171247.png" alt="libgo三大结构体关系" title="主要结构体关系"></p>
<h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 <strong>Scheduler</strong></h3><ul>
<li>libgo/scheduler/scheduler.h</li>
</ul>
<ul>
<li><p>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协程调度器</span></span><br><span class="line"><span class="comment">// 负责管理1到N个调度线程, 调度从属协程.</span></span><br><span class="line"><span class="comment">// 可以调用Create接口创建更多额外的调度器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Processer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">static</span> Scheduler&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建一个调度器，初始化 libgo</span></span><br><span class="line">	<span class="comment">// 创建主线程的执行器，如果后续 STart 的时候没有参数，默认只有一个执行器去做</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Scheduler* <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个协程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateTask</span><span class="params">(TaskF <span class="keyword">const</span>&amp; fn, TaskOpt <span class="keyword">const</span>&amp; opt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前是否处于协程中</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsCoroutine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否没有协程可执行</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动调度器</span></span><br><span class="line">    <span class="comment">// @minThreadNumber : 最小调度线程数, 为0时, 设置为cpu核心数.</span></span><br><span class="line">    <span class="comment">// @maxThreadNumber : 最大调度线程数, 为0时, 设置为minThreadNumber.</span></span><br><span class="line">    <span class="comment">//          如果maxThreadNumber大于minThreadNumber, 则当协程产生长时间阻塞时,</span></span><br><span class="line">    <span class="comment">//          可以自动扩展调度线程数.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> minThreadNumber = <span class="number">1</span>, <span class="keyword">int</span> maxThreadNumber = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goStart</span><span class="params">(<span class="keyword">int</span> minThreadNumber = <span class="number">1</span>, <span class="keyword">int</span> maxThreadNumber = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_ulimitedMaxThreadNumber = <span class="number">40960</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止调度 </span></span><br><span class="line">    <span class="comment">// 注意: 停止后无法恢复, 仅用于安全退出main函数, 不保证终止所有线程.</span></span><br><span class="line">    <span class="comment">//       如果某个调度线程被协程阻塞, 必须等待阻塞结束才能退出.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用独立的定时器线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UseAloneTimerThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前调度器中的协程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">TaskCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前协程ID, ID从1开始（不在协程中则返回0）</span></span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">GetCurrentTaskID</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前协程切换的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">GetCurrentTaskYieldCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前协程调试信息, 打印调试信息时将回显</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetCurrentTaskDebugInfo</span><span class="params">(std::string <span class="keyword">const</span>&amp; info)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> Timer&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;&gt; TimerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> TimerType &amp; <span class="title">GetTimer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timer_ ? *timer_ : <span class="built_in">StaticGetTimer</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsStop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> stop_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span>&amp; <span class="title">IsExiting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">idx_t</span>     = std::<span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> ActiveMap = std::multimap&lt;std::<span class="keyword">size_t</span>, <span class="keyword">idx_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> BlockMap  = std::map&lt;<span class="keyword">idx_t</span>, std::<span class="keyword">size_t</span>&gt;;</span><br><span class="line">    <span class="built_in">Scheduler</span>();</span><br><span class="line">    ~<span class="built_in">Scheduler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Scheduler</span>(Scheduler <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Scheduler</span>(Scheduler &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Scheduler&amp; <span class="keyword">operator</span>=(Scheduler <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Scheduler&amp; <span class="keyword">operator</span>=(Scheduler &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteTask</span><span class="params">(RefObject* tk, <span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个协程加入可执行队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddTask</span><span class="params">(Task* tk)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatcher线程函数</span></span><br><span class="line">    <span class="comment">// 1.根据待执行协程计算负载, 将高负载的P中的协程steal一些给空载的P</span></span><br><span class="line">    <span class="comment">// 2.侦测到阻塞的P(单个协程运行时间超过阀值), 将P中的其他协程steal给其他P</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DispatcherThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NewProcessThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DispatchBlocks</span><span class="params">(BlockMap &amp;blockings,ActiveMap &amp;actives)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadBalance</span><span class="params">(ActiveMap &amp;actives,std::<span class="keyword">size_t</span> activeTasks)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TimerType &amp; <span class="title">StaticGetTimer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque of Processer, write by start or dispatch thread</span></span><br><span class="line">    Deque&lt;Processer*&gt; processers_;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// libgo的自旋锁</span></span><br><span class="line">    LFLock started_;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 协程数量</span></span><br><span class="line">    <span class="keyword">atomic_t</span>&lt;<span class="keyword">uint32_t</span>&gt; taskCount_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> lastActive_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TimerType *timer_ = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> minThreadNumber_ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxThreadNumber_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::thread dispatchThread_;</span><br><span class="line"></span><br><span class="line">    std::thread timerThread_;</span><br><span class="line"></span><br><span class="line">    std::mutex stopMtx_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> stop_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>调度器的使用</p>
<ul>
<li>系统默认的调度器调度器<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_Scheduler ::co::Scheduler::getInstance()</span></span><br><span class="line"><span class="comment">// co_sched</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> co_sched g_Scheduler</span></span><br></pre></td></tr></table></figure></li>
<li>用户也可以创建自己的协程调度器<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">co::Scheduler* my_sched = co::Scheduler::<span class="built_in">Create</span>();</span><br></pre></td></tr></table></figure></li>
<li>启动调度<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([my_sched]&#123;mysched-&gt;Start();&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调度器原理</p>
</li>
</ul>
<ol>
<li><p>schedule 负责整个系统的协程调度，协程的运行依赖于<code>执行器</code> Processer（简称 P），因此在调度器初始化的时候会选择创建 P 的数量（支持动态增长），所有的执行器会添加到双端队列中。主线程也作为一个<code>执行器</code>，在创建 Scheduler 对象的时候创建，位于双端队列下标为 0 的位置（注意：只是创建对象，并没有开始运行）；</p>
</li>
<li><p>当调用了 Start() 函数后，会正式开始运行。在 Start 函数内部，会创建指定数量的执行器 P，具体数量取决于参数，默认会创建 minThreadNumber 个，当全部执行器都阻塞之后，会动态扩展，最多 maxThreadNumber 个执行器。每个执行器都会运行于一个单独的线程，执行器负责该线程内部协程的切换和执行；</p>
</li>
<li><p>当创建协程时，会将协程添加到某一个处于活跃状态的执行器，如果恰好都不活跃，也会添加到某一个 P 中，这并不影响执行器的正常工作，因为调度器的调度线程会去处理它；</p>
</li>
<li><p>Start 函数内部，除了上述执行器所在线程，还会开启调度线程 <code>DispatcherThread</code>，调度线程会平衡各个 P 的协程数量和负载，进行 steal，如果所有 P 都阻塞，会根据 maxThreadNumber 动态增加 P 的数量，如果仅仅部分 P 阻塞，会将阻塞的 P 中的协程全部拿出（steal），均摊到负载最小的 P 中；</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在start函数中另起一个调度线程，运行DispatcherThread调度函数</span></span><br><span class="line"><span class="comment">// 调度线程</span></span><br><span class="line">   <span class="keyword">if</span> (maxThreadNumber_ &gt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">DebugPrint</span>(dbg_scheduler, <span class="string">&quot;---&gt; Create DispatcherThread&quot;</span>);</span><br><span class="line">       <span class="function">std::thread <span class="title">t</span><span class="params">([<span class="keyword">this</span>]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">               DebugPrint(dbg_thread, <span class="string">&quot;Start dispatcher(sched=%p) thread id: %lu&quot;</span>, (<span class="keyword">void</span>*)<span class="keyword">this</span>, NativeThreadID());</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">this</span>-&gt;DispatcherThread();</span></span></span><br><span class="line"><span class="params"><span class="function">               &#125;)</span></span>;</span><br><span class="line">       dispatchThread_.<span class="built_in">swap</span>(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Schedule 也会选择性开启协程的定时器线程；</p>
</li>
<li><p>开启 FastSteadyClock 线程。</p>
</li>
</ol>
<h3 id="执行器-Processor"><a href="#执行器-Processor" class="headerlink" title="执行器 Processor"></a>执行器 <strong>Processor</strong></h3><ul>
<li><p>libgo/scheduler/processer.h</p>
</li>
<li><p>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协程执行器</span></span><br><span class="line"><span class="comment">// 对应一个线程, 负责本线程的协程调度, 非线程安全.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 改执行器依赖的调度器</span></span><br><span class="line">    Scheduler * scheduler_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">int</span> id_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活态</span></span><br><span class="line">    <span class="comment">// 非激活的P仅仅是不能接受新的协程加入, 仍然可以强行AddTask并正常处理.</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> active_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在运行的协程</span></span><br><span class="line">    Task* runningTask_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    Task* nextTask_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每轮调度只加有限次数新协程, 防止新协程创建新协程产生死循环</span></span><br><span class="line">    <span class="keyword">int</span> addNewQuota_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在运行的协程本次调度开始的时间戳(Dispatch线程专用)</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int64_t</span> markTick_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint64_t</span> markSwitch_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程调度次数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint64_t</span> switchCount_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程队列</span></span><br><span class="line">    <span class="keyword">typedef</span> TSQueue&lt;Task, <span class="literal">true</span>&gt; TaskQueue;</span><br><span class="line">    TaskQueue runnableQueue_;</span><br><span class="line">    TaskQueue waitQueue_;</span><br><span class="line">    TSQueue&lt;Task, <span class="literal">false</span>&gt; gcQueue_;</span><br><span class="line"></span><br><span class="line">    TaskQueue newQueue_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待的条件变量</span></span><br><span class="line">    std::condition_variable_any cv_;</span><br><span class="line">    std::<span class="keyword">atomic_bool</span> waiting_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> notified_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_check_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">int</span> <span class="title">Id</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Processer* &amp; <span class="title">GetCurrentProcesser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Scheduler* <span class="title">GetCurrentScheduler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Scheduler* <span class="title">GetScheduler</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> scheduler_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前正在执行的协程</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Task* <span class="title">GetCurrentTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否在协程中</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsCoroutine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程切出</span></span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StaticCoYield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起标识，用于后续挂起和超时判断</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SuspendEntry</span> &#123;</span></span><br><span class="line">        WeakPtr&lt;Task&gt; tk_;</span><br><span class="line">        <span class="keyword">uint64_t</span> id_;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !!tk_; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(SuspendEntry <span class="keyword">const</span>&amp; lhs, SuspendEntry <span class="keyword">const</span>&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.tk_ == rhs.tk_ &amp;&amp; lhs.id_ == rhs.id_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(SuspendEntry <span class="keyword">const</span>&amp; lhs, SuspendEntry <span class="keyword">const</span>&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.id_ == rhs.id_)</span><br><span class="line">                <span class="keyword">return</span> lhs.tk_ &lt; rhs.tk_;</span><br><span class="line">            <span class="keyword">return</span> lhs.id_ &lt; rhs.id_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">IsExpire</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Processer::<span class="built_in">IsExpire</span>(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起当前协程</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SuspendEntry <span class="title">Suspend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起当前协程, 并在指定时间后自动唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SuspendEntry <span class="title">Suspend</span><span class="params">(FastSteadyClock::duration dur)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SuspendEntry <span class="title">Suspend</span><span class="params">(FastSteadyClock::time_point timepoint)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒协程</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Wakeup</span><span class="params">(SuspendEntry <span class="keyword">const</span>&amp; entry, std::function&lt;<span class="keyword">void</span>()&gt; <span class="keyword">const</span>&amp; functor = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一个SuspendEntry是否还可能有效</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsExpire</span><span class="params">(SuspendEntry <span class="keyword">const</span>&amp; entry)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// --------------------------------------</span></span><br><span class="line">    <span class="comment">// for friend class Scheduler</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Processer</span><span class="params">(Scheduler * scheduler, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待执行的协程数量</span></span><br><span class="line">    <span class="comment">// 暂兼用于负载指数</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">RunnableSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">CoYield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新创建、阻塞后触发的协程add进来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddTask</span><span class="params">(Task *tk)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷来的协程add进来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddTask</span><span class="params">(SList&lt;Task&gt; &amp;&amp; slist)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否处于等待状态(无runnable协程)</span></span><br><span class="line">    <span class="comment">// 调度线程会尽量分配协程过来</span></span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">bool</span> <span class="title">IsWaiting</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> waiting_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个协程执行时长超过预设值, 则判定为阻塞状态</span></span><br><span class="line">    <span class="comment">// 阻塞状态不再加入新的协程, 并由调度线程steal走所有协程(正在执行的除外)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBlocking</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷协程</span></span><br><span class="line">    <span class="function">SList&lt;Task&gt; <span class="title">Steal</span><span class="params">(std::<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="comment">/// --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WaitCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">AddNewTasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度线程打标记, 用于检测阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int64_t</span> <span class="title">NowMicrosecond</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SuspendEntry <span class="title">SuspendBySelf</span><span class="params">(Task* tk)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">WakeupBySelf</span><span class="params">(IncursivePtr&lt;Task&gt; <span class="keyword">const</span>&amp; tkPtr, <span class="keyword">uint64_t</span> id, std::function&lt;<span class="keyword">void</span>()&gt; <span class="keyword">const</span>&amp; functor)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="执行器对线程的调度"><a href="#执行器对线程的调度" class="headerlink" title="执行器对线程的调度"></a>执行器对线程的调度</h4><p>使用函数process()</p>
<ul>
<li>执行器维护了许多协程队列<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 协程队列</span></span><br><span class="line">   <span class="keyword">typedef</span> TSQueue&lt;Task, <span class="literal">true</span>&gt; TaskQueue;</span><br><span class="line"><span class="comment">// 可运行协程队列</span></span><br><span class="line">   TaskQueue runnableQueue_;</span><br><span class="line"><span class="comment">// 存放挂起的协程</span></span><br><span class="line">   TaskQueue waitQueue_;</span><br><span class="line">   TSQueue&lt;Task, <span class="literal">false</span>&gt; gcQueue_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该队列中存放的是新加入的协程，包括新创建的协程，唤醒挂起的协程，还有 steal 来的协程</span></span><br><span class="line">   TaskQueue newQueue_;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="process-函数处理流程"><a href="#process-函数处理流程" class="headerlink" title="process()函数处理流程"></a>process()函数处理流程</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processer::Process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GetCurrentProcesser</span>() = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LIBGO_SYS_Windows)</span></span><br><span class="line">    FiberScopedGuard sg;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!scheduler_-&gt;<span class="built_in">IsStop</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        runnableQueue_.<span class="built_in">front</span>(runningTask_);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!runningTask_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">AddNewTasks</span>())</span><br><span class="line">                runnableQueue_.<span class="built_in">front</span>(runningTask_);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!runningTask_) &#123;</span><br><span class="line">				<span class="comment">// 没有可以运行的协程则wait</span></span><br><span class="line">                <span class="built_in">WaitCondition</span>();</span><br><span class="line">                <span class="built_in">AddNewTasks</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">        <span class="built_in">DebugPrint</span>(dbg_scheduler, <span class="string">&quot;Run [Proc(%d) QueueSize:%lu] --------------------------&quot;</span>, id_, <span class="built_in">RunnableSize</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        addNewQuota_ = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (runningTask_ &amp;&amp; !scheduler_-&gt;<span class="built_in">IsStop</span>()) &#123;</span><br><span class="line">            runningTask_-&gt;state_ = TaskState::runnable;</span><br><span class="line">            runningTask_-&gt;proc_ = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">            <span class="built_in">DebugPrint</span>(dbg_switch, <span class="string">&quot;enter task(%s)&quot;</span>, runningTask_-&gt;<span class="built_in">DebugInfo</span>());</span><br><span class="line">            <span class="keyword">if</span> (Listener::<span class="built_in">GetTaskListener</span>())</span><br><span class="line">                Listener::<span class="built_in">GetTaskListener</span>()-&gt;<span class="built_in">onSwapIn</span>(runningTask_-&gt;id_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            ++switchCount_;</span><br><span class="line"></span><br><span class="line">            runningTask_-&gt;<span class="built_in">SwapIn</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">            <span class="built_in">DebugPrint</span>(dbg_switch, <span class="string">&quot;leave task(%s) state=%d&quot;</span>, runningTask_-&gt;<span class="built_in">DebugInfo</span>(), (<span class="keyword">int</span>)runningTask_-&gt;state_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (runningTask_-&gt;state_) &#123;</span><br><span class="line">                <span class="keyword">case</span> TaskState::runnable:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function">std::unique_lock&lt;TaskQueue::<span class="keyword">lock_t</span>&gt; <span class="title">lock</span><span class="params">(runnableQueue_.LockRef())</span></span>;</span><br><span class="line">                        <span class="keyword">auto</span> next = (Task*)runningTask_-&gt;next;</span><br><span class="line">                        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">                            runningTask_ = next;</span><br><span class="line">                            runningTask_-&gt;check_ = runnableQueue_.check_;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (addNewQuota_ &lt; <span class="number">1</span> || newQueue_.<span class="built_in">emptyUnsafe</span>()) &#123;</span><br><span class="line">                            runningTask_ = <span class="literal">nullptr</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lock.<span class="built_in">unlock</span>();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">AddNewTasks</span>()) &#123;</span><br><span class="line">                                runnableQueue_.<span class="built_in">next</span>(runningTask_, runningTask_);</span><br><span class="line">                                -- addNewQuota_;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                std::unique_lock&lt;TaskQueue::<span class="keyword">lock_t</span>&gt; <span class="built_in">lock2</span>(runnableQueue_.<span class="built_in">LockRef</span>());</span><br><span class="line">                                runningTask_ = <span class="literal">nullptr</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TaskState::block:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function">std::unique_lock&lt;TaskQueue::<span class="keyword">lock_t</span>&gt; <span class="title">lock</span><span class="params">(runnableQueue_.LockRef())</span></span>;</span><br><span class="line">                        runningTask_ = nextTask_;</span><br><span class="line">                        nextTask_ = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TaskState::done:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        runnableQueue_.<span class="built_in">next</span>(runningTask_, nextTask_);</span><br><span class="line">                        <span class="keyword">if</span> (!nextTask_ &amp;&amp; addNewQuota_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">AddNewTasks</span>()) &#123;</span><br><span class="line">                                runnableQueue_.<span class="built_in">next</span>(runningTask_, nextTask_);</span><br><span class="line">                                -- addNewQuota_;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">DebugPrint</span>(dbg_task, <span class="string">&quot;task(%s) done.&quot;</span>, runningTask_-&gt;<span class="built_in">DebugInfo</span>());</span><br><span class="line">                        runnableQueue_.<span class="built_in">erase</span>(runningTask_);</span><br><span class="line">						<span class="comment">// 执行完回收</span></span><br><span class="line">                        <span class="keyword">if</span> (gcQueue_.<span class="built_in">size</span>() &gt; <span class="number">16</span>)</span><br><span class="line">                            <span class="built_in">GC</span>();</span><br><span class="line">                        gcQueue_.<span class="built_in">push</span>(runningTask_);</span><br><span class="line">                        <span class="keyword">if</span> (runningTask_-&gt;eptr_) &#123;</span><br><span class="line">                            std::exception_ptr ep = runningTask_-&gt;eptr_;</span><br><span class="line">                            std::<span class="built_in">rethrow_exception</span>(ep);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function">std::unique_lock&lt;TaskQueue::<span class="keyword">lock_t</span>&gt; <span class="title">lock</span><span class="params">(runnableQueue_.LockRef())</span></span>;</span><br><span class="line">                        runningTask_ = nextTask_;</span><br><span class="line">                        nextTask_ = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在调度器 Schedule 执行 Stop() 函数之前，执行器 P 会一直处于调度协程阶段 Process()。在期间，执行器 P 会将运行队列 runnableQueue_ 中的第一个协程获取进行执行，如果可运行队列为空，执行器会尝试将处于 newQueue_ 中的协程添加到可运行队列中去，如果 newQueue_ 为空，说明此时该执行器处于无协程可调度状态，通过设置条件变量，将执行器设置为等待状态；</p>
</li>
<li><p>当获取到一个可执行协程之后，会执行该协程的任务。协程的执行流程是通过状态机来实现的。（协程有三个状态：运行中，阻塞，执行完毕）</p>
</li>
<li><p>对于运行中的协程，我们只需要确定下一个要执行的协程对象即可；</p>
</li>
<li><p>对于阻塞的协程，只有当协程挂起时（调用了 Suspend 方法），状态才会切换到这里，因此，这时候只需要去执行 nextTask 即可；</p>
</li>
<li><p>对于运行完毕的协程，只有当 Task 处理函数执行完成之后，状态才会切换到这里，因此，需要考虑对该协程资源进行回收；</p>
</li>
</ol>
<h4 id="使用条件变量唤醒"><a href="#使用条件变量唤醒" class="headerlink" title="使用条件变量唤醒"></a>使用条件变量唤醒</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processer::WaitCondition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GC</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cvMutex_)</span></span>;</span><br><span class="line">    waiting_ = <span class="literal">true</span>;</span><br><span class="line">    cv_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    waiting_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processer::NotifyCondition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps: 这里使用的是带超时时间的返回，原因在于，在等待新协程的同时，可以定时跳出做一些检查。</p>
<h4 id="从该执行器中偷取指定数量的协程"><a href="#从该执行器中偷取指定数量的协程" class="headerlink" title="从该执行器中偷取指定数量的协程"></a>从该执行器中偷取指定数量的协程</h4><pre><code>-    steal()
</code></pre>
<p>从该执行器的双端队列里面获取指定数量的协程</p>
<ul>
<li><p>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SList&lt;Task&gt; <span class="title">Processer::Steal</span><span class="params">(std::<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// steal some</span></span><br><span class="line">        newQueue_.<span class="built_in">AssertLink</span>();</span><br><span class="line">        <span class="keyword">auto</span> slist = newQueue_.<span class="built_in">pop_back</span>(n);</span><br><span class="line">        newQueue_.<span class="built_in">AssertLink</span>();</span><br><span class="line">        <span class="keyword">if</span> (slist.<span class="built_in">size</span>() &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> slist;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;TaskQueue::<span class="keyword">lock_t</span>&gt; <span class="title">lock</span><span class="params">(runnableQueue_.LockRef())</span></span>;</span><br><span class="line">        <span class="keyword">bool</span> pushRunningTask = <span class="literal">false</span>, pushNextTask = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (runningTask_)</span><br><span class="line">            pushRunningTask = runnableQueue_.<span class="built_in">eraseWithoutLock</span>(runningTask_, <span class="literal">true</span>) || slist.<span class="built_in">erase</span>(runningTask_, newQueue_.check_);</span><br><span class="line">        <span class="keyword">if</span> (nextTask_)</span><br><span class="line">            pushNextTask = runnableQueue_.<span class="built_in">eraseWithoutLock</span>(nextTask_, <span class="literal">true</span>) || slist.<span class="built_in">erase</span>(nextTask_, newQueue_.check_);</span><br><span class="line">        <span class="keyword">auto</span> slist2 = runnableQueue_.<span class="built_in">pop_backWithoutLock</span>(n - slist.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span> (pushRunningTask)</span><br><span class="line">            runnableQueue_.<span class="built_in">pushWithoutLock</span>(runningTask_);</span><br><span class="line">        <span class="keyword">if</span> (pushNextTask)</span><br><span class="line">            runnableQueue_.<span class="built_in">pushWithoutLock</span>(nextTask_);</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        slist2.<span class="built_in">append</span>(std::<span class="built_in">move</span>(slist));</span><br><span class="line">        <span class="keyword">if</span> (!slist2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">DebugPrint</span>(dbg_scheduler, <span class="string">&quot;Proc(%d).Stealed = %d&quot;</span>, id_, (<span class="keyword">int</span>)slist2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> slist2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// steal all</span></span><br><span class="line">        newQueue_.<span class="built_in">AssertLink</span>();</span><br><span class="line">        <span class="keyword">auto</span> slist = newQueue_.<span class="built_in">pop_all</span>();</span><br><span class="line">        newQueue_.<span class="built_in">AssertLink</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;TaskQueue::<span class="keyword">lock_t</span>&gt; <span class="title">lock</span><span class="params">(runnableQueue_.LockRef())</span></span>;</span><br><span class="line">        <span class="keyword">bool</span> pushRunningTask = <span class="literal">false</span>, pushNextTask = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (runningTask_)</span><br><span class="line">            pushRunningTask = runnableQueue_.<span class="built_in">eraseWithoutLock</span>(runningTask_, <span class="literal">true</span>) || slist.<span class="built_in">erase</span>(runningTask_, newQueue_.check_);</span><br><span class="line">        <span class="keyword">if</span> (nextTask_)</span><br><span class="line">            pushNextTask = runnableQueue_.<span class="built_in">eraseWithoutLock</span>(nextTask_, <span class="literal">true</span>) || slist.<span class="built_in">erase</span>(nextTask_, newQueue_.check_);</span><br><span class="line">        <span class="keyword">auto</span> slist2 = runnableQueue_.<span class="built_in">pop_allWithoutLock</span>();</span><br><span class="line">        <span class="keyword">if</span> (pushRunningTask)</span><br><span class="line">            runnableQueue_.<span class="built_in">pushWithoutLock</span>(runningTask_);</span><br><span class="line">        <span class="keyword">if</span> (pushNextTask)</span><br><span class="line">            runnableQueue_.<span class="built_in">pushWithoutLock</span>(nextTask_);</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        slist2.<span class="built_in">append</span>(std::<span class="built_in">move</span>(slist));</span><br><span class="line">        <span class="keyword">if</span> (!slist2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">DebugPrint</span>(dbg_scheduler, <span class="string">&quot;Proc(%d).Stealed all = %d&quot;</span>, id_, (<span class="keyword">int</span>)slist2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> slist2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>窃取的流程</p>
</li>
</ul>
<ol>
<li><p>首先，会从 newQueue_ 队列中获取协程结点，因为 newQueue_ 中的结点还没有添加到运行队列中，因此可以直接取出；如果 newQueue_ 中协程数量不足，会从 runnableQueue_ 队列尾部中继续获取结点。由于 runnableQueue_ 队列中我们记录了正在执行的协程和下一次将执行的协程（runningTask_ &amp; nextTask_），需要特殊处理。在从 runnableQueue_ 偷协程之前，会将 runningTask_ &amp; nextTask_ 从队列删除，待偷完结点之后再次添加到当前 runnableQueue_ 队列中。</p>
</li>
<li><p>简单说，偷协程的工作，不会从队列中获取到 runningTask_ &amp; nextTask_ 标识的协程。</p>
</li>
</ol>
<h4 id="阻塞判断"><a href="#阻塞判断" class="headerlink" title="阻塞判断"></a>阻塞判断</h4><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Processer::IsBlocking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!markSwitch_ || markSwitch_ != switchCount_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NowMicrosecond</span>() &gt; markTick_ + CoroutineOptions::<span class="built_in">getInstance</span>().cycle_timeout_us;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processer::Mark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningTask_ &amp;&amp; markSwitch_ != switchCount_) &#123;</span><br><span class="line">        markSwitch_ = switchCount_;</span><br><span class="line">        markTick_ = <span class="built_in">NowMicrosecond</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单协程执行超时时长(单位：微秒) (超过时长会强制steal剩余任务, 派发到其他线程)</span></span><br><span class="line"><span class="keyword">uint32_t</span> cycle_timeout_us = <span class="number">100</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>Mark 函数会在调度器的调度函数中被调用，需要注意的是，只有执行器处于活跃状态时才会调用。Mark 顾名思义，是给该执行打标记，会记录mark的时间戳，并记录下是在第多少次协程调度的过程中做了标记，Mark 的作用是用来进行执行器的阻塞检测。</p>
</li>
<li><p>处于活跃状态的执行器，总是在执行着协程的切换，因此，会不断自增 switchCount_ 的值，根据 IsBlocking 函数得知，当我们此时标签记录的协程调度次数超过100ms没有发生改变，我们认为该执行器发生阻塞，Scheduler 会进行 Steal 操作。</p>
</li>
</ol>
<h4 id="协程挂起-suspend"><a href="#协程挂起-suspend" class="headerlink" title="协程挂起 suspend"></a>协程挂起 suspend</h4><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 挂起当前协程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SuspendEntry <span class="title">Suspend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起当前协程, 并在指定时间后自动唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SuspendEntry <span class="title">Suspend</span><span class="params">(FastSteadyClock::duration dur)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SuspendEntry <span class="title">Suspend</span><span class="params">(FastSteadyClock::time_point timepoint)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>一种方式是直接挂起，会将该协程状态转换为 TaskState::block，然后将该协程从 runnableQueue_ 中删除，再添加到 waitQueue_ 中；</p>
</li>
<li><p>另外一种方式是挂起之后（第一种方式执行完毕之后），允许配置一个时间段之后去自动唤醒该协程。</p>
</li>
</ol>
<h4 id="协程的唤起"><a href="#协程的唤起" class="headerlink" title="协程的唤起"></a>协程的唤起</h4><ul>
<li>wakeup<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒协程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Wakeup</span><span class="params">(SuspendEntry <span class="keyword">const</span>&amp; entry, std::function&lt;<span class="keyword">void</span>()&gt; <span class="keyword">const</span>&amp; functor = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
用于唤醒协程<br>唤醒协程要做的，就是讲待唤醒的协程从 waitQueue_ 中删除并重新添加到 newQueue_中去。</li>
</ul>
<h4 id="协程的切出"><a href="#协程的切出" class="headerlink" title="协程的切出"></a>协程的切出</h4><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协程切出</span></span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StaticCoYield</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">Processer::StaticCoYield</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> proc = <span class="built_in">GetCurrentProcesser</span>();</span><br><span class="line">    <span class="keyword">if</span> (proc) proc-&gt;<span class="built_in">CoYield</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">Processer::CoYield</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task *tk = <span class="built_in">GetCurrentTask</span>();</span><br><span class="line">    <span class="built_in">assert</span>(tk);</span><br><span class="line"></span><br><span class="line">    ++ tk-&gt;yieldCount_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">    <span class="built_in">DebugPrint</span>(dbg_yield, <span class="string">&quot;yield task(%s) state = %s&quot;</span>, tk-&gt;<span class="built_in">DebugInfo</span>(), <span class="built_in">GetTaskStateName</span>(tk-&gt;state_));</span><br><span class="line">    <span class="keyword">if</span> (Listener::<span class="built_in">GetTaskListener</span>())</span><br><span class="line">        Listener::<span class="built_in">GetTaskListener</span>()-&gt;<span class="built_in">onSwapOut</span>(tk-&gt;id_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    tk-&gt;<span class="built_in">SwapOut</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
用于在一个执行器中切出当前协程<br>有两种可能:</li>
</ul>
<ol>
<li>一种是协程被阻塞需要挂起；</li>
<li>另外一种是协程执行完毕，主动切出。具体实现是通过获取当前执行器正在执行的协程 Task，调用 SwapOut() 方法实现。</li>
</ol>
<ul>
<li>什么时候会切出：<ul>
<li>协程被挂起</li>
<li>协程执行完毕</li>
<li>用户主动使用co_yield切出<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> co_yield do &#123; ::co::Processer::StaticCoYield(); &#125; while (0)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="协程-TASK"><a href="#协程-TASK" class="headerlink" title="协程 TASK"></a>协程 <strong>TASK</strong></h3><ul>
<li>libgo/task/task.h</li>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协程状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">TaskState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    runnable, <span class="comment">// 可运行</span></span><br><span class="line">    block, <span class="comment">// 阻塞</span></span><br><span class="line">    done, <span class="comment">// 完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> TSQueueHook, <span class="keyword">public</span> SharedRefObject, <span class="keyword">public</span> CoDebugger::DebuggerBase&lt;Task&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TaskState state_ = TaskState::runnable;</span><br><span class="line">    <span class="keyword">uint64_t</span> id_;</span><br><span class="line">    Processer* proc_ = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">// 上下文</span></span><br><span class="line">    Context ctx_;</span><br><span class="line">    TaskF fn_;</span><br><span class="line">    std::exception_ptr eptr_;           <span class="comment">// 保存exception的指针</span></span><br><span class="line">    TaskAnys anys_;</span><br><span class="line">    <span class="keyword">void</span>* extern_switcher_ &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> yieldCount_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_t</span>&lt;<span class="keyword">uint64_t</span>&gt; suspendId_ &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(TaskF <span class="keyword">const</span>&amp; fn, std::<span class="keyword">size_t</span> stack_size);</span><br><span class="line">    ~<span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">SwapIn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ctx_.<span class="built_in">SwapIn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ALWAYS_INLINE void SwapTo(Task* other)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    ctx_.SwapTo(other-&gt;ctx_);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">SwapOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ctx_.<span class="built_in">SwapOut</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">DebugInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> FCONTEXT_CALL <span class="title">StaticRun</span><span class="params">(<span class="keyword">intptr_t</span> vp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Task</span>(Task &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
每个 Task 对象是一个协程，在使用过程中，创建一个协程实际就是创建了一个 Task 对象，再添加到对应的执行器 P 中。之前提到过，执行器进行协程调度是通过一个状态机来实现的，这里的 TaskState 就是协程状态，协程函数 fn_ 会在 StaticRun 静态方法中调用，该静态方法注册到了协程上下文 _ctx 中。</li>
</ul>
<p>除此之外，Task 类内部，也提供了协程的切入切出方法，本质也是调用了上下文的切换。</p>
<h4 id="协程的运行"><a href="#协程的运行" class="headerlink" title="协程的运行"></a>协程的运行</h4><ul>
<li>StaticRun<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过staticrun调用run</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> FCONTEXT_CALL <span class="title">Task::StaticRun</span><span class="params">(<span class="keyword">intptr_t</span> vp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task* tk = (Task*)vp;</span><br><span class="line">    tk-&gt;<span class="built_in">Run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> call_fn = [<span class="keyword">this</span>]() &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">        <span class="keyword">if</span> (Listener::<span class="built_in">GetTaskListener</span>()) &#123;</span><br><span class="line">            Listener::<span class="built_in">GetTaskListener</span>()-&gt;<span class="built_in">onStart</span>(<span class="keyword">this</span>-&gt;id_);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">fn_</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;fn_ = <span class="built_in">TaskF</span>(); <span class="comment">//让协程function对象的析构也在协程中执行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">        <span class="keyword">if</span> (Listener::<span class="built_in">GetTaskListener</span>()) &#123;</span><br><span class="line">            Listener::<span class="built_in">GetTaskListener</span>()-&gt;<span class="built_in">onCompleted</span>(<span class="keyword">this</span>-&gt;id_);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CoroutineOptions::<span class="built_in">getInstance</span>().exception_handle == eCoExHandle::immedaitely_throw) &#123;</span><br><span class="line">        <span class="built_in">call_fn</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">call_fn</span>();</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fn_ = <span class="built_in">TaskF</span>();</span><br><span class="line"></span><br><span class="line">            std::exception_ptr eptr = std::<span class="built_in">current_exception</span>();</span><br><span class="line">            <span class="built_in">DebugPrint</span>(dbg_exception, <span class="string">&quot;task(%s) catched exception.&quot;</span>, <span class="built_in">DebugInfo</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">            <span class="keyword">if</span> (Listener::<span class="built_in">GetTaskListener</span>()) &#123;</span><br><span class="line">                Listener::<span class="built_in">GetTaskListener</span>()-&gt;<span class="built_in">onException</span>(<span class="keyword">this</span>-&gt;id_, eptr);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_DEBUGGER</span></span><br><span class="line">    <span class="keyword">if</span> (Listener::<span class="built_in">GetTaskListener</span>()) &#123;</span><br><span class="line">        Listener::<span class="built_in">GetTaskListener</span>()-&gt;<span class="built_in">onFinished</span>(<span class="keyword">this</span>-&gt;id_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 完成则状态改变加切出</span></span><br><span class="line">    state_ = TaskState::done;</span><br><span class="line">    Processer::<span class="built_in">StaticCoYield</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="hook系统调用原理"><a href="#hook系统调用原理" class="headerlink" title="hook系统调用原理"></a>hook系统调用原理</h2><ul>
<li><p>libgo/netio/unix/hook.cpp</p>
</li>
<li><p>源码</p>
<ul>
<li>以几个hook的系统函数为例</li>
</ul>
</li>
<li><p>sleep</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sleep函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sleep_f) <span class="built_in">initHook</span>();</span><br><span class="line"></span><br><span class="line">    Task* tk = Processer::<span class="built_in">GetCurrentTask</span>();</span><br><span class="line">    <span class="built_in">DebugPrint</span>(dbg_hook, <span class="string">&quot;task(%s) hook sleep(seconds=%u). %s coroutine.&quot;</span>,</span><br><span class="line">            tk-&gt;<span class="built_in">DebugInfo</span>(), seconds,</span><br><span class="line">            Processer::<span class="built_in">IsCoroutine</span>() ? <span class="string">&quot;In&quot;</span> : <span class="string">&quot;Not in&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tk)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sleep_f</span>(seconds);</span><br><span class="line"></span><br><span class="line">    Processer::<span class="built_in">Suspend</span>(std::chrono::<span class="built_in">seconds</span>(seconds));</span><br><span class="line">    Processer::<span class="built_in">StaticCoYield</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上是接管原先的系统函数，使用libgo的函数。sleep这里直接掉了执行器挂起指定时间</p>
</li>
<li><p>read</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!read_f) <span class="built_in">initHook</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_write_mode</span>(fd, read_f, <span class="string">&quot;read&quot;</span>, POLLIN, SO_RCVTIMEO, count, buf, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OriginF, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">read_write_mode</span><span class="params">(<span class="keyword">int</span> fd, OriginF fn, <span class="keyword">const</span> <span class="keyword">char</span>* hook_fn_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">short</span> <span class="keyword">int</span> event, <span class="keyword">int</span> timeout_so, <span class="keyword">ssize_t</span> buflen, Args &amp;&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task* tk = Processer::<span class="built_in">GetCurrentTask</span>();</span><br><span class="line">    <span class="built_in">DebugPrint</span>(dbg_hook, <span class="string">&quot;task(%s) hook %s(fd=%d, buflen=%d). %s coroutine.&quot;</span>,</span><br><span class="line">            tk-&gt;<span class="built_in">DebugInfo</span>(), hook_fn_name, fd, (<span class="keyword">int</span>)buflen,</span><br><span class="line">            Processer::<span class="built_in">IsCoroutine</span>() ? <span class="string">&quot;In&quot;</span> : <span class="string">&quot;Not in&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tk)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fn</span>(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">    FdContextPtr ctx = HookHelper::<span class="built_in">getInstance</span>().<span class="built_in">GetFdContext</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ctx || ctx-&gt;<span class="built_in">IsNonBlocking</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fn</span>(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> socketTimeout = ctx-&gt;<span class="built_in">GetSocketTimeoutMicroSeconds</span>(timeout_so);</span><br><span class="line">    <span class="keyword">int</span> pollTimeout = (socketTimeout == <span class="number">0</span>) ? <span class="number">-1</span> : (socketTimeout &lt; <span class="number">1000</span> ? <span class="number">1</span> : socketTimeout / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line">    fds.fd = fd;</span><br><span class="line">    fds.events = event;</span><br><span class="line">    fds.revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">eintr:</span><br><span class="line">    <span class="keyword">int</span> triggers = <span class="built_in">libgo_poll</span>(&amp;fds, <span class="number">1</span>, pollTimeout, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == triggers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) <span class="keyword">goto</span> eintr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == triggers) &#123;  <span class="comment">// poll等待超时</span></span><br><span class="line">        errno = EAGAIN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry_intr_fn:</span><br><span class="line">    <span class="keyword">ssize_t</span> res = <span class="built_in">fn</span>(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            <span class="keyword">goto</span> retry_intr_fn;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read变成了一个加入libgo_poll的事件，等待触发，从而被hook掉</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架学习</category>
        <category>libgo</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile语法</title>
    <url>/2022/04/07/makefile%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>一般来说，无论是C还是C++，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p>
<p>在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File），也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>
<p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 </p>
<span id="more"></span>

<!-- toc -->
<p><a href="https://seisman.github.io/how-to-write-makefile/">参考文章</a></p>
<h2 id="makefile的规则"><a href="#makefile的规则" class="headerlink" title="makefile的规则"></a>makefile的规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>target</strong><br>  可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
</li>
<li><p><strong>prerequisites</strong><br>  生成该target所依赖的文件和/或target</p>
</li>
<li><p><strong>command</strong><br>  该target要执行的命令（任意的shell命令）</p>
</li>
</ul>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。<br><em><strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</strong></em></p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><ul>
<li>申明变量<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></li>
<li>使用变量<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="make自动推导"><a href="#make自动推导" class="headerlink" title="make自动推导"></a>make自动推导</h2><p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来。</p>
<h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p> <code>.PHONY</code> 表示 <code>clean</code> 是一个“伪目标”。而在 <code>rm</code> 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。</p>
<h2 id="Makefile包含"><a href="#Makefile包含" class="headerlink" title="Makefile包含"></a>Makefile包含</h2><ul>
<li>显式规则。显式规则说明了如何生成一个或多个目标文件。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。</li>
<li>注释</li>
</ul>
<h2 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>

<h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="Makefile通配符"><a href="#Makefile通配符" class="headerlink" title="Makefile通配符"></a>Makefile通配符</h3><p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> 。<br>如果是 <code>~/test</code> ，这就表示当前用户的 <code>$HOME</code> 目录下的test目录。<br>通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： <code>*</code> ，那么可以用转义字符 <code>\</code> ，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。</p>
<h2 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h2><p>Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<p>上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<h3 id="另一个方法"><a href="#另一个方法" class="headerlink" title="另一个方法"></a>另一个方法</h3><p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code><br>为符合模式<pattern>的文件指定搜索目录<directories>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>
<p>该语句表示，要求make在“../headers”目录下搜索所有以 <code>.h</code> 结尾的文件。（如果某文件在当前目录没有找到的话）</p>
<h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
<p>“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<h2 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li><p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
</li>
<li><p>target-pattern是指明了targets的模式，也就是的目标集模式。</p>
</li>
<li><p>prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">##############							</span></span><br><span class="line">上面的例子中，指明了我们的目标从$object中获取， `%.o` 表明要所有以 `.o` 结尾的目标，也就是 `foo.o bar.o` ，也就是变量 `$object` 集合的模式，而依赖模式 `%.c` 则取模式 `%.o` 的 `%` ，也就是 `foo bar` ，并为其加下 `.c` 的后缀，于是，我们的依赖目标就是 `foo.c bar.c` 。而命令中的 `<span class="variable">$&lt;</span>` 和 `<span class="variable">$@</span>` 则是自动化变量， `<span class="variable">$&lt;</span>` 表示第一个依赖文件， `<span class="variable">$@</span>` 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</span><br><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h3><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>当我们用 <code>@</code> 字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p>
<p>@echo 正在编译XXX模块……<br>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令</p>
<ul>
<li>make参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令</li>
<li>make参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</li>
</ul>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>

<h3 id="命令的出错"><a href="#命令的出错" class="headerlink" title="命令的出错"></a>命令的出错</h3><p>忽略命令的出错，我们可以在Makefile的命令行前加一个减号 - （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure>
<p>还有一个全局的办法是，给make加上 -i 或是 –ignore-errors 参数，那么，Makefile中所有命令都会忽略错误。<br>还有一个要提一下的make的参数的是 -k 或是 –keep-going ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<h3 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h3><p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明:</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明:</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</li>
</ul>
<h3 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 define 开始，以 endef 结束，如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 : 、 # 、 = 或是空字符（空格、回车等）。变量是大小写敏感的。</p>
<h3 id="变量基础"><a href="#变量基础" class="headerlink" title="变量基础"></a>变量基础</h3><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来。如果你要使用真实的 <code>$</code> 字符，那么你需要用 <code>$$</code> 来表示。<br>变量会在使用它的地方精确地展开，就像C/C++中的宏一样。</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><ul>
<li><p>方法1:运行使用的变量后面在定义</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法2:这种方法，前面的变量不能使用后面的变量，避免递归</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4></li>
<li><p>定义一个空格</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>错误使用</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure>
<p>这里dir后面会跟着4个空格</p>
<ul>
<li><code>?=</code>的使用<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>
如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做。</li>
</ul>
<h3 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h3><h4 id="变量字符替换"><a href="#变量字符替换" class="headerlink" title="变量字符替换"></a>变量字符替换</h4><p>我们可以替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br><span class="line"><span class="comment">### 等价（静态模式）</span></span><br><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>
<p>把 $(foo) 中所有以 .o 字串“结尾”全部替换成 .c ，所以我们的 $(bar) 的值就是“a.c b.c c.c”。</p>
<h4 id="把变量的值再当成变量"><a href="#把变量的值再当成变量" class="headerlink" title="把变量的值再当成变量"></a>把变量的值再当成变量</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>

<h3 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h3><p>我们可以使用 <code>+=</code> 操作符给变量追加值</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> another.o</span><br></pre></td></tr></table></figure>

<h3 id="override-指示符"><a href="#override-指示符" class="headerlink" title="override 指示符"></a>override 指示符</h3><p>通常在执行 make 时,如果通过命令行定义了一个变量,那么它将替代在 Makefile中出现的同名变量的定义。<br>就是说,对于一个在 Makefile 中使用常规方式(使用“=”、“:=”或者“define”)定义的变量,我们可以在执行 make 时通过命令行方式重新指定这个变量的值,命令行指定的值将替代出现在 Makefile 中此变量的值。<br>override作用:</p>
<ul>
<li>保护makefile中定义的变量的值;</li>
<li>提供一种在makefile中增加或者修改命令行参数的方式;</li>
</ul>
<h3 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h3><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以<code>[Tab]</code>键开头，所以如果你用define定义的命令变量中没有以 <code>Tab</code> 键开头，那么make就不会把其认为是命令。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用export关键字来声明。</p>
<h3 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h3><p>因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<ul>
<li>格式<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;;</span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure></li>
<li>例子<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， $(CFLAGS) 的值都是 -g</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h3><p>我们可以以如下方式给所有以 .o 结尾的目标定义目标变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>

<h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p>自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件。</p>
<h2 id="使用条件变量"><a href="#使用条件变量" class="headerlink" title="使用条件变量"></a>使用条件变量</h2><ul>
<li><p>例子</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
<li><p>语法</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
<li><p>三种关键字</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifneq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifdef</span> &lt;variable-name&gt;</span><br><span class="line"><span class="keyword">ifndef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;conditional-directive&gt;</code> 这一行上，多余的空格是被允许的，但是不能以 <code>Tab</code> 键作为开始（不然就被认为是命令）。而注释符 <code>#</code> 同样也是安全的。 <code>else</code> 和 <code>endif</code> 也一样，只要不是以 <code>Tab</code> 键开始就行了。</p>
</li>
</ul>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><h3 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><code> &lt;function&gt;</code> 就是函数名,<code>&lt;arguments&gt;</code> 为函数的参数。参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li><p>subst</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 把字串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt; 。</span></span><br></pre></td></tr></table></figure></li>
<li><p>patsubst</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 查找 &lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 &lt;pattern&gt; ，如果匹配的话，则以 &lt;replacement&gt; 替换。</span></span><br></pre></td></tr></table></figure></li>
<li><p>strip</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br><span class="line"><span class="comment"># 去掉 &lt;string&gt; 字串中开头和结尾的空字符。</span></span><br></pre></td></tr></table></figure></li>
<li><p>findstring</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br><span class="line"><span class="comment"># 如果找到，那么返回 &lt;find&gt; ，否则返回空字符串。</span></span><br></pre></td></tr></table></figure></li>
<li><p>filter</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词。可以有多个模式。</span></span><br></pre></td></tr></table></figure></li>
<li><p>filter-out</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，去除符合模式 &lt;pattern&gt; 的单词。可以有多个模式。</span></span><br></pre></td></tr></table></figure></li>
<li><p>sort</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br><span class="line"><span class="comment"># 给字符串 &lt;list&gt; 中的单词排序（升序）</span></span><br></pre></td></tr></table></figure></li>
<li><p>word</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从一开始）</span></span><br></pre></td></tr></table></figure></li>
<li><p>wordlist</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。 &lt;ss&gt; 和 &lt;e&gt; 是一个数字。</span></span><br></pre></td></tr></table></figure></li>
<li><p>words</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 返回 &lt;text&gt; 中的单词数</span></span><br></pre></td></tr></table></figure></li>
<li><p>firstword</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 返回字符串 &lt;text&gt; 的第一个单词。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h3><ul>
<li><p>dir</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 从文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./ 。</span></span><br></pre></td></tr></table></figure></li>
<li><p>notdir</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分。</span></span><br></pre></td></tr></table></figure></li>
<li><p>suffix</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 从文件名序列 &lt;names&gt; 中取出各个文件名的后缀。</span></span><br></pre></td></tr></table></figure></li>
<li><p>basename</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 返回文件名序列 &lt;names&gt; 的前缀序列，如果文件没有前缀，则返回空字串。</span></span><br></pre></td></tr></table></figure></li>
<li><p>addsuffix</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 把后缀 &lt;suffix&gt; 加到 &lt;names&gt; 中的每个单词后面。</span></span><br></pre></td></tr></table></figure></li>
<li><p>addprefix</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span></span><br><span class="line"><span class="comment"># 把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词前面。</span></span><br></pre></td></tr></table></figure></li>
<li><p>join</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br><span class="line"><span class="comment"># 把 &lt;list2&gt; 中的单词对应地加到 &lt;list1&gt; 的单词后面。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 这个函数的意思是，把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中， &lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</span></span><br></pre></td></tr></table></figure>
<p>注意，foreach中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用，其作用域只在foreach函数当中。</p>
<h3 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br><span class="line"><span class="comment"># 如果 &lt;condition&gt; 为真（非空字符串），那个 &lt;then-part&gt; 会是整个函数的返回值，如果 &lt;condition&gt; 为假（空字符串），那么 &lt;else-part&gt; 会是整个函数的返回值，此时如果 &lt;else-part&gt; 没有被定义，那么，整个函数返回空字串。</span></span><br></pre></td></tr></table></figure>

<h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</span></span><br><span class="line"><span class="comment"># 当make执行这个函数时， &lt;expression&gt; 参数中的变量，如 $(1) 、 $(2) 等，会被参数 &lt;parm1&gt; 、 &lt;parm2&gt; 、 &lt;parm3&gt; 依次取代。而 &lt;expression&gt; 的返回值就是 call 函数的返回值。</span></span><br><span class="line">reverse =  $(1) $(2)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure>

<h3 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>&lt;variable&gt;</code> 从来没有定义过，origin函数返回这个值 <code>undefined</code></li>
<li>如果 <code>&lt;variable&gt;</code> 是一个默认的定义，比如“CC”这个变量，返回<code>default</code></li>
<li>如果 <code>&lt;variable&gt;</code> 是一个环境变量，返回<code>environment</code></li>
<li>如果 <code>&lt;variable&gt;</code> 这个变量被定义在Makefile中。返回<code>file</code></li>
<li>如果 <code>&lt;variable&gt;</code> 这个变量是被命令行定义的。返回<code>command line</code></li>
<li>如果 <code>&lt;variable&gt;</code> 是被override指示符重新定义的。<code>override</code></li>
<li>如果 <code>&lt;variable&gt;</code> 是一个命令运行中的自动化变量。<code>automatic</code></li>
</ul>
<h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure>

<h3 id="控制make的函数"><a href="#控制make的函数" class="headerlink" title="控制make的函数"></a>控制make的函数</h3><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<ul>
<li>产生错误<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure></li>
<li>产生warning<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="make的运行"><a href="#make的运行" class="headerlink" title="make的运行"></a>make的运行</h2><h3 id="make的退出码"><a href="#make的退出码" class="headerlink" title="make的退出码"></a>make的退出码</h3><p>makefile执行命令后有三个错误码</p>
<ul>
<li>0:<ul>
<li>表示成功执行</li>
</ul>
</li>
<li>1:<ul>
<li>如果make运行时出现任何错误，其返回1。</li>
</ul>
</li>
<li>2:<ul>
<li>如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li>
</ul>
</li>
</ul>
<h3 id="指定makefile文件"><a href="#指定makefile文件" class="headerlink" title="指定makefile文件"></a>指定makefile文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure>
<h3 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: prog1 prog2 prog3 prog4</span></span><br><span class="line"><span class="comment"># 我们也可以使用 “make prog2”来单独编译目标“prog2”。</span></span><br></pre></td></tr></table></figure>

<h3 id="检查规则"><a href="#检查规则" class="headerlink" title="检查规则"></a>检查规则</h3><ul>
<li>-n, –just-print, –dry-run, –recon<br>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行。</li>
<li>-t, –touch<br>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</li>
<li>-q, –question<br>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</li>
<li>-W&lt;file&gt;, –what-if=&lt;file&gt;, –assume-new=&lt;file&gt;, –new-file=&lt;file&gt;<br>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</li>
</ul>
<h2 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h2><p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把 .c 文件编译成 .o 文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的 .o 文件。</p>
<h3 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="comment"># 因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<h3 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h3><p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 <code>CC</code> ；一种是参数相的关，如 <code>CFLAGS</code> 。<br>下面是所有隐含规则中会用到的变量：</p>
<ul>
<li>命令的变量<ul>
<li>CC : C语言编译程序。默认命令是 cc</li>
<li>CXX : C++语言编译程序。默认命令是 g++</li>
<li>等等</li>
</ul>
</li>
<li>命令参数的变量<ul>
<li>CFLAGS : C语言编译器参数。</li>
<li>CXXFLAGS : C++语言编译器参数</li>
<li>等等</li>
</ul>
</li>
</ul>
<h3 id="隐含规则链"><a href="#隐含规则链" class="headerlink" title="隐含规则链"></a>隐含规则链</h3><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 .o 的文件生成，可能会是先被 Yacc的[.y]文件先成 .c ，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<h3 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h3><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 % 字符。 % 的意思是表示一个或多个任意字符。<br>有一点需要注意的是， % 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入 Makefile时，而模式规则中的 % 则发生在运行时。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c ; &lt;command ......&gt;;</span><br><span class="line"><span class="comment"># 其含义是，指出了怎么从所有的 .c 文件生成相应的 .o 文件的规则。如果要生成的目标是 a.o b.o ，那么 %c 就是 a.c b.c 。</span></span><br></pre></td></tr></table></figure>
<h4 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>$@</code> : 表示所有的目标的挨个值</li>
<li><code>$&lt;</code> : 表示了所有依赖目标的挨个值</li>
</ul>
<h4 id="自动化变量-1"><a href="#自动化变量-1" class="headerlink" title="自动化变量"></a>自动化变量</h4><p>如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。自动化变量就是完成这个功能的。</p>
<ul>
<li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li>
<li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code> ，那么， <code>$%</code> 就是 bar.o ， <code>$@</code> 就是 foo.a 。</li>
<li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。</li>
<li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li>
<li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。那么这个变量会去除重复的依赖目标，只保留一份。</li>
<li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 $* 就是除了后缀的那一部分。</li>
</ul>
<p>下面是对于上面的七个变量分别加上 D 或是 F 的含义：</p>
<ul>
<li><code>$(@D)</code><br>表示 <code>$@</code> 的目录部分（不以斜杠作为结尾），如果 <code>$@</code> 值是 dir/foo.o ，那么 <code>$(@D)</code> 就是 dir ，而如果 <code>$@</code> 中没有包含斜杠的话，其值就是 . （当前目录）。</li>
<li><code>$(@F)</code><br>表示 <code>$@</code> 的文件部分，如果 <code>$@</code> 值是 dir/foo.o ，那么 <code>$(@F)</code> 就是 foo.o ， <code>$(@F)</code> 相当于函数 <code>$(notdir $@)</code> 。</li>
</ul>
]]></content>
      <categories>
        <category>makefile</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>obsidian_markdown</title>
    <url>/2022/02/09/obsidian-markdown/</url>
    <content><![CDATA[<hr>
<p>由于typora收费了，改用obsidian。obisidian的markdown语法稍微有些不一样，特别是图片的插入，因此原先的一套博客系统的图片管理方式需要变化。因此该文章主要用来测试图片插入与现在的博客系统如何兼容，顺道系统学习下markdown语法。</p>
<span id="more"></span>
<!-- toc -->

<p>[toc]</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="标题分为6级"><a href="#标题分为6级" class="headerlink" title="标题分为6级"></a>标题分为6级</h3><ul>
<li>使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级</span><br><span class="line">## 二级</span><br><span class="line">###</span><br><span class="line">...</span><br><span class="line">######</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>使用格式<br><code>[toc]</code><br>但是不是所有markdown都支持</li>
</ul>
<h2 id="斜体-amp-粗体"><a href="#斜体-amp-粗体" class="headerlink" title="斜体&amp;粗体"></a>斜体&amp;粗体</h2><h3 id="斜体使用格式："><a href="#斜体使用格式：" class="headerlink" title="斜体使用格式："></a><em>斜体</em>使用格式：</h3><ol>
<li><code>*文本内容*</code></li>
<li><code>_文本内容_</code></li>
</ol>
<h3 id="粗体-使用格式："><a href="#粗体-使用格式：" class="headerlink" title="__粗体__使用格式："></a>__粗体__使用格式：</h3><ol>
<li><code>**文本内容**</code></li>
<li><code>__文本内容__</code></li>
</ol>
<h3 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a><em><strong>粗斜体</strong></em></h3><p>三个</p>
<h2 id="线-水平分割线"><a href="#线-水平分割线" class="headerlink" title="线-水平分割线"></a>线-水平分割线</h2><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<hr>
<h3 id="文本删除线"><a href="#文本删除线" class="headerlink" title="文本删除线"></a>文本删除线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~文章内容~~</span><br></pre></td></tr></table></figure>
<p><del>文章内容</del></p>
<h3 id="文本下划线"><a href="#文本下划线" class="headerlink" title="文本下划线"></a>文本下划线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;文本内容&lt;/u&gt;</span><br></pre></td></tr></table></figure>
<p>示范:<br><u>文本内容</u></p>
<h2 id="列表-amp-引用"><a href="#列表-amp-引用" class="headerlink" title="列表&amp;引用"></a>列表&amp;引用</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.+空格+文本内容</span><br><span class="line"></span><br><span class="line">1. 这是第一个有序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line">2. 这是第二个有序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line">3. 这是第三个有序列表 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 这是第一个有序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">   这是同个列表下，另起一行的文本内容 &lt;!-- (Enter) --&gt;</span><br><span class="line">2. 这是第二个有序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">   这是同个列表下，另起一行的文本内容 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>格式：<br><code>- + 空格 + 文本内容</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 这是第1个无序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line">- 这是第2个无序列表 &lt;!-- (Enter) --&gt;</span><br><span class="line">- 这是第3个无序列表</span><br><span class="line"></span><br><span class="line">- 这是第一个无序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">  这是同个列表下，另起一行的文本内容</span><br><span class="line">- 这是第二个无序列表 &lt;!-- (Shift + Enter) --&gt;</span><br><span class="line">  这是同个列表下，另起一行的文本内容 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个</li>
<li>第二个</li>
<li>第三个</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>格式：<br><code>&gt;+文本内容 不需要空格</code></p>
<blockquote>
<p>nima </p>
</blockquote>
<h3 id="缩紧和退格"><a href="#缩紧和退格" class="headerlink" title="缩紧和退格"></a>缩紧和退格</h3><p>格式:</p>
<ul>
<li><p>缩进：</p>
<ol>
<li><code>tab</code></li>
<li><code>ctrl</code> + <code>[</code></li>
</ol>
</li>
<li><p>退格：</p>
<ol>
<li><code>shift</code> + <code>tab</code></li>
<li><code>shift</code> + <code>]</code></li>
</ol>
</li>
</ul>
<h4 id="有序列表的缩和退"><a href="#有序列表的缩和退" class="headerlink" title="有序列表的缩和退"></a>有序列表的缩和退</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一级有序列表1 &lt;!-- (Enter) --&gt;</span><br><span class="line">	1. 第二级有序列表1    &lt;!-- 写文本之前，先( Tab 或 Ctrl + ] ) ；写完文本后，再(Enter) --&gt;</span><br><span class="line">	2. 第二级有序列表2 &lt;!-- (Enter) --&gt;</span><br><span class="line">2. 第一级有序列表2    &lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --&gt; </span><br></pre></td></tr></table></figure>
<ol>
<li>第一级列表<ol>
<li>tab后</li>
<li>2</li>
</ol>
</li>
<li>第二级列表</li>
</ol>
<h4 id="无序列表类似啊"><a href="#无序列表类似啊" class="headerlink" title="无序列表类似啊"></a>无序列表类似啊</h4><ul>
<li>第一级<ul>
<li>第一级下的tab</li>
</ul>
</li>
<li>第二级</li>
</ul>
<h4 id="引用的缩-amp-退"><a href="#引用的缩-amp-退" class="headerlink" title="引用的缩&amp;退"></a>引用的缩&amp;退</h4><p>只需要多打一个&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;第一级引用1 &lt;!-- (enter) --&gt;</span><br><span class="line">&gt;&gt;第二级引用1 &lt;!-- 先打1个 &gt; (这里的第一个 &gt; 是会自动补充的，只需额外增补1个即可) ，再(enter) --&gt;</span><br><span class="line">&gt;&gt;第二级引用2 &lt;!-- (enter) --&gt;</span><br><span class="line">&gt;第一级引用2   &lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1</p>
<blockquote>
<p>1.1</p>
<blockquote>
<p>1.1.11</p>
</blockquote>
<p>2.1</p>
</blockquote>
<p>2</p>
</blockquote>
<p>ps: obsidian的这个缩进真的奇怪</p>
<h2 id="网页链接与图像"><a href="#网页链接与图像" class="headerlink" title="网页链接与图像"></a>网页链接与图像</h2><h3 id="网页链接"><a href="#网页链接" class="headerlink" title="网页链接"></a>网页链接</h3><ul>
<li>格式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[显示文本的内容]+(链接地址 + &quot;提示文本信息&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[显示文本内容](链接地址 &quot;提示信息文本&quot;)</span><br><span class="line"></span><br><span class="line">[百度一下，你就知道](http://www.baidu.com &quot;按住Ctrl点击跳转百度&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a href="http://www.baidu.com/" title="按住Ctrl点击跳转百度">百度一下，你就知道</a></li>
</ul>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul>
<li><p>图像格式:</p>
<ul>
<li>图像格式，网页前面加个!</li>
<li>提示信息 写在””</li>
<li>[]方括号里的文字信息在 Markdown 没啥实质的作用，只是方便在源代码模式下，知道这个图片是什么，在渲染界面是不会显示的。有点类似于HTML img标签 里的 alt属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![文字信息](图片链接 &quot;提示文本信息&quot;)	</span><br><span class="line"></span><br><span class="line">![湘湖1](upload://Ad5F9UZAOlZkz4iRuGeEuRugdZ.jpeg &quot;湘湖一角&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>obsidian嵌套图片<br>![[20220208173252.png|100]]<br>明显在博客中会失效</p>
</li>
<li><p>markdown格式图片<br><img src="/2022/02/09/obsidian-markdown/20220208173252.png" alt="名字|100x100" title="痛いよ"><br>图片大小设置无法成功（markdown语法的图片大小设置与编辑器有关），路径和hexo博客兼容</p>
</li>
<li><p>html格式图片修改大小</p>
<img src="20220208173252.png" alt="20220208173252.png" style="zoom:60%;" align="center"  /></li>
<li><p>html格式图片大小无修改</p>
<img src="20220208173252.png" />
老板的html格式图片路径是可以在博客上正确显示的，但是obsidian就无法显示本地格式的</li>
</ul>
<ul>
<li>网络图片<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.jj20.com%2Fup%2Fallimg%2F1114%2F022221105922%2F210222105922-7-1200.jpg&refer=http%3A%2F%2Fimg.jj20.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646962404&t=d8e3455fdc34efb4153e5780430e3981" /></li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul>
<li><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|这里是表头1|这里是表头2|这里是表头3|</span><br><span class="line">|:-|:-:|-:|    &lt;!--区分表头和表格主体，:代表文本对齐方式，分别是左对齐，居中对齐，右对齐--&gt;</span><br><span class="line">|单元格数据1|单元格数据2|单元格数据3|</span><br><span class="line">|单元格数据4|单元格数据5|单元格数据6|</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>示范</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nfds</td>
<td align="left">int</td>
<td align="left">文件描述符最大值+1</td>
</tr>
<tr>
<td align="left">readfds</td>
<td align="left">fd_set *</td>
<td align="left">读事件文件描述符集合</td>
</tr>
<tr>
<td align="left">writefds</td>
<td align="left">fd_set *</td>
<td align="left">写事件文件描述符集合</td>
</tr>
<tr>
<td align="left">exceptfds</td>
<td align="left">fd_set *</td>
<td align="left">异常事件文件描述符集合</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">timeval *</td>
<td align="left">超时时间，超过该时间即使没有事件到达，select也会返回，避免无休止地等待</td>
</tr>
</tbody></table>
<h3 id="表格内容换行"><a href="#表格内容换行" class="headerlink" title="表格内容换行"></a>表格内容换行</h3><ul>
<li>若想对一段长文本进行换行，可以在 <strong>中间</strong> 插入一个 <strong><code>&lt;br&gt;</code></strong> （ 换行标签 )<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 表头1 |  表头2 |</span><br><span class="line">|:-:|:-:|</span><br><span class="line">|这是第一行文本&lt;br&gt;这是另起一行的文本|普通文本|</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>示范</li>
</ul>
<table>
<thead>
<tr>
<th align="center">表头1</th>
<th align="center">表头2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">这是第一行文本<br>这是另起一行的文本</td>
<td align="center">普通文本</td>
</tr>
</tbody></table>
<h2 id="代码域"><a href="#代码域" class="headerlink" title="代码域"></a>代码域</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><ul>
<li>格式</li>
</ul>
<p>输入两个反撇号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`这是一段行内代码`</span><br><span class="line"></span><br><span class="line">`&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;`</span><br><span class="line"></span><br><span class="line">`print(&quot;Hello, World!&quot;)`</span><br><span class="line"></span><br><span class="line">`这是一行突出显示的文本内容`</span><br></pre></td></tr></table></figure>
<ul>
<li>示范</li>
</ul>
<p><code>这是一段行内代码</code></p>
<p><code>&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;</code></p>
<p><code>print(&quot;Hello, World!&quot;)</code></p>
<p><code>这是一行突出显示的文本内容</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul>
<li>格式</li>
</ul>
<ol>
<li>三个反撇号+语言种类</li>
<li>三个波浪号+语言种类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```语言种类</span><br><span class="line">代码内容</span><br><span class="line">代码内容</span><br><span class="line">代码内容</span><br></pre></td></tr></table></figure>

<h2 id="任务列表（代办）"><a href="#任务列表（代办）" class="headerlink" title="任务列表（代办）"></a>任务列表（代办）</h2><ul>
<li><p><code>-</code>+<code>空格</code>+[ ]+<code>空格</code>+任务内容</p>
</li>
<li><p>格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [ ] 待办任务列表1</span><br><span class="line">- [ ] 待办任务列表2</span><br><span class="line">- [x] 已办任务列表1    &lt;!-- 英文字母X --&gt;</span><br><span class="line">- [x] 已办任务列表2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>示范</p>
</li>
<li><p><input disabled="" type="checkbox">  待办任务列表1</p>
</li>
<li><p><input disabled="" type="checkbox">  待办任务列表2</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  已办任务列表1    <!-- 英文字母X --></p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  已办任务列表2</p>
</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>markdown注释和html一样，注释内容在渲染界面看不见</p>
<ul>
<li>格式<br>  <code>&lt;!-- 注释的内容 --&gt;</code></li>
<li>示范<br>  看不见的<!-- 注释的内容 --></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="网页链接变量"><a href="#网页链接变量" class="headerlink" title="网页链接变量"></a>网页链接变量</h3><ul>
<li>格式<br>  [显示文本]+[变量名]</li>
<li>设置变量<br>  [变量名]+<code>:</code>+<code>空格</code>+链接地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[百度一下，你就知道][度娘]</span><br><span class="line">[知乎-有问题，就会有答案][知乎]</span><br><span class="line"></span><br><span class="line">&lt;!-- 这里是变量区域 --&gt;</span><br><span class="line">[度娘]: http://www.baidu.com </span><br><span class="line">[知乎]: https://www.zhihu.com </span><br></pre></td></tr></table></figure>

<ul>
<li>示范</li>
</ul>
<p><a href="http://www.baidu.com/">百度一下，你就知道</a><br><a href="https://www.zhihu.com/">知乎-有问题，就会有答案</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ul>
<li>格式<br>  [^脚注代号]</li>
<li>设置变量<br>  [^脚注代号]+<code>:</code>+<code>空格</code>+脚注内容</li>
<li>示范<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">树上春树[^1]</span><br><span class="line">米津玄师[^2]</span><br><span class="line">&lt;!-- 设置变量 --&gt;</span><br><span class="line">[^1]: 日本作家</span><br><span class="line">[^2]: 日本歌手</span><br></pre></td></tr></table></figure>
树上春树<a href="%E6%97%A5%E6%9C%AC%E4%BD%9C%E5%AE%B6">^1</a><br>米津玄师<a href="%E6%97%A5%E6%9C%AC%E6%AD%8C%E6%89%8B">^2</a></li>
</ul>
<h2 id="扩展文本"><a href="#扩展文本" class="headerlink" title="扩展文本"></a>扩展文本</h2><h3 id="键盘文本"><a href="#键盘文本" class="headerlink" title="键盘文本"></a>键盘文本</h3><ul>
<li>格式<br><kbd>键盘文本</kbd></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;kbd&gt;键盘文本&lt;/kbd&gt;</span><br></pre></td></tr></table></figure>

<p>ps: 键盘文本就是一种着重文本</p>
<h3 id="放大文本"><a href="#放大文本" class="headerlink" title="放大文本"></a>放大文本</h3><ul>
<li>放大文本格式<br><big>这是一段放大了的文本</big><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;big&gt;这是一段放大了的文本&lt;/big&gt;</span><br></pre></td></tr></table></figure>
<h3 id="缩小文本"><a href="#缩小文本" class="headerlink" title="缩小文本"></a>缩小文本</h3></li>
<li>缩小文本格式<br><small>这是一段缩小文本</small><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;small&gt;这是一段缩小文本&lt;/small&gt;</span><br></pre></td></tr></table></figure>
<h3 id="多彩文本"><a href="#多彩文本" class="headerlink" title="多彩文本"></a>多彩文本</h3></li>
<li>多彩文本的格式<br><font color=violet>紫罗兰色</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=violet&gt;紫罗兰色&lt;/font&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>ps :color 支持英文单词，16禁止，rgb，rgba</p>
<h2 id="扩展文本-1"><a href="#扩展文本-1" class="headerlink" title="扩展文本"></a>扩展文本</h2><h3 id="文本高亮"><a href="#文本高亮" class="headerlink" title="文本高亮"></a>文本高亮</h3><ul>
<li>文本高亮格式<br>==高亮内容==<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==高亮内容==</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><ul>
<li>格式1<br><code>x^2^</code><br>x^2^<br>obsidian编辑器不支持</li>
<li>格式2html<br><code>&lt;sup&gt;内容&lt;/sup&gt;</code><br>x<sup>2</sup></li>
</ul>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><ul>
<li>格式1<br>H<del>2</del>O<br><code>H~2~O</code><br>obsidian不支持</li>
<li>格式2 html<br><code>&lt;sub&gt;这里是下标内容&lt;/sub&gt;</code><br>H<sub>2</sub>O</li>
</ul>
<h3 id="emoji符号"><a href="#emoji符号" class="headerlink" title="emoji符号"></a>emoji符号</h3><ul>
<li><p>格式<br>使用<code>:</code>包裹英文</p>
</li>
<li><p>测试<br><code>:smile:</code></p>
</li>
<li><p>效果<br>:smile:</p>
</li>
</ul>
<p>ps:只有部分编辑器支持</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ul>
<li>使用代码块</li>
<li>使用转义字符反斜杠<code>\</code></li>
</ul>
<h3 id="注意下反撇号"><a href="#注意下反撇号" class="headerlink" title="注意下反撇号`"></a>注意下反撇号<kbd>`</kbd></h3><ul>
<li>在行内代码中，让反撇号 <strong>`</strong> 能被显示出来，有两种方法<ol>
<li>首尾用<strong>两个引号</strong>包裹<br> <strong><code>`显示2个反撇号`</code></strong> ， <strong><code>`显示单个反撇号</code></strong> </li>
</ol>
<ul>
<li>  <strong>效果：</strong> <strong><code>`显示两个反撇号`</code></strong> ， <strong><code> `显示单个反撇号</code></strong></li>
<li><strong>注意：</strong> 中间的内容 距离首尾引号 各有1个空格</li>
</ul>
<ol start="2">
<li>之前提过，行内代码也可作为 突出显示的文本<br> 可以利用前面介绍的 键盘文本 + 转义符号 <strong><code>\</code></strong> ，突出显示反撇号<ul>
<li>  <strong>格式：</strong> <strong><code>&lt;kbd&gt;\`首尾的反撇号会正常显示\`&lt;/kbd&gt;</code></strong></li>
<li>  <strong>效果：</strong> <code>首尾的反撇号会正常显示</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="空格-amp-换行-amp-强制删除"><a href="#空格-amp-换行-amp-强制删除" class="headerlink" title="空格&amp;换行&amp;强制删除"></a>空格&amp;换行&amp;强制删除</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul>
<li>使用html的<strong>空格</strong>字符：—— <code>&amp;nbsp;</code></li>
<li>多个空格：<ul>
<li><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;</code></li>
</ul>
</li>
<li>效果<ul>
<li>这里有&nbsp;&nbsp;&nbsp;三个空格</li>
</ul>
</li>
</ul>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>使用<code>&lt;br&gt;</code></li>
</ul>
<h3 id="强制删除"><a href="#强制删除" class="headerlink" title="强制删除"></a>强制删除</h3><ul>
<li>使用Shift+Backspace强制删除</li>
</ul>
<h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>markdown的所有嵌入都是通过html实现的</p>
<h3 id="嵌入音频"><a href="#嵌入音频" class="headerlink" title="嵌入音频"></a>嵌入音频</h3><ul>
<li>格式<br><code>&lt;audio controls=&quot;controls&quot; preload=&quot;none&quot; src=&quot;音频链接地址&quot;&gt;&lt;/audio&gt;</code></li>
<li>示范<br><code>&lt;audio controls=&quot;controls&quot; preload=&quot;none&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=512359195&amp;auto=1&amp;height=66&quot;&gt;&lt;/audio&gt;</code></li>
<li>效果</li>
</ul>
<p><audio controls="controls" preload="none" src="//music.163.com/outchain/player?type=2&id=512359195&auto=1&height=66"></audio></p>
<h3 id="嵌入视频"><a href="#嵌入视频" class="headerlink" title="嵌入视频"></a>嵌入视频</h3><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video width=&quot;600&quot; height=&quot;420&quot; controls&gt;</span><br><span class="line">  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot;&gt;  </span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="嵌入页面"><a href="#嵌入页面" class="headerlink" title="嵌入页面"></a>嵌入页面</h3><ul>
<li><p>格式<br><code>&lt;iframe width=600 height=400 src=&quot;https://www.runoob.com/html/html-tutorial.html&quot; scrolling=&quot;auto&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></p>
</li>
<li><p>效果</p>
<iframe width=600 height=400 src="https://www.bilibili.com" scrolling="auto" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li>
</ul>
<h2 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h2><p>主要是用来书写<code>化学公式</code>和<code>数学公式</code></p>
<ul>
<li><p>格式<br><code>$</code>+行内公式+<code>$</code></p>
</li>
<li><p>实例<br><code>$\ce&#123;CO2 + C -&gt; 2 CO&#125;$</code><br><code>$x^2 + 2x + 5 + \sqrt x = 0$</code></p>
</li>
</ul>
<p>-效果</p>
<p>$\ce{CO2 + C -&gt; 2 CO}$</p>
<p>$x^2 + 2x + 5 + \sqrt x = 0$</p>
<h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">公式块</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><p>通过mermaid来画各种各样的图</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><ul>
<li><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">emperor((朱八八))-.子.-&gt;朱五四-.子.-&gt;朱四九-.子.-&gt;朱百六</span><br><span class="line">朱雄英--长子--&gt;朱标--长子--&gt;emperor</span><br><span class="line">emperor2((朱允炆))--次子--&gt;朱标</span><br><span class="line">朱樉--次子--&gt;emperor</span><br><span class="line">朱棡--三子--&gt;emperor</span><br><span class="line">emperor3((朱棣))--四子--&gt;emperor</span><br><span class="line">emperor4((朱高炽))--长子--&gt;emperor3</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
<li><p>渲染图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">emperor((朱八八))-.子.-&gt;朱五四-.子.-&gt;朱四九-.子.-&gt;朱百六</span><br><span class="line">朱雄英--长子--&gt;朱标--长子--&gt;emperor</span><br><span class="line">emperor2((朱允炆))--次子--&gt;朱标</span><br><span class="line">朱樉--次子--&gt;emperor</span><br><span class="line">朱棡--三子--&gt;emperor</span><br><span class="line">emperor3((朱棣))--四子--&gt;emperor</span><br><span class="line">emperor4((朱高炽))--长子--&gt;emperor3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><ul>
<li><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;夢なし&quot; : 45</span><br><span class="line">    &quot;友達なし&quot; : 70</span><br><span class="line">    &quot;お金なし&quot; : 500</span><br><span class="line">	&quot;家が好き&quot; : 95</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
<li><p>渲染图</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;夢なし&quot; : 45</span><br><span class="line">    &quot;友達なし&quot; : 70</span><br><span class="line">    &quot;お金なし&quot; : 500</span><br><span class="line">	&quot;家が好き&quot; : 95</span><br></pre></td></tr></table></figure>

<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>太复杂了，单独学语法吧</p>
<h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><ul>
<li><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
<li><p>渲染图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>功能测试</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>vegeta测试</title>
    <url>/2022/04/14/vegete%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Vegeta 是一个用 Go 语言编写的多功能的 HTTP 负载测试工具，它提供了命令行工具和一个开发库。 </p>
<span id="more"></span>

<!-- toc -->

<h2 id="什么是-Vegeta"><a href="#什么是-Vegeta" class="headerlink" title="什么是 Vegeta"></a><strong>什么是 Vegeta</strong></h2><p><a href="https://github.com/tsenart/vegeta">官方地址</a></p>
<h2 id="Vegeta-用法"><a href="#Vegeta-用法" class="headerlink" title="Vegeta 用法"></a>Vegeta 用法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vegeta --help  </span><br><span class="line">Usage: vegeta [global flags] &lt;command&gt; [command flags]  </span><br><span class="line">   </span><br><span class="line">global flags:  </span><br><span class="line"> -cpus int  </span><br><span class="line"> 使用 CPU 的数量 (默认为 4 个)  </span><br><span class="line"> -profile string  </span><br><span class="line"> 指定在执行期间启用哪个分析器，支持 cpu 和 heap。   </span><br><span class="line"> -version  </span><br><span class="line"> 打印版本并退出。  </span><br><span class="line">   </span><br><span class="line">attack command:  </span><br><span class="line"> -body string  </span><br><span class="line"> 指定请求主体文件里的内容。  </span><br><span class="line"> -cert string  </span><br><span class="line"> 指定用于 HTTPS 请求的 PEM 格式的客户端证书文件。如果 -key 未指定，它会被设置为这个标志的值。  </span><br><span class="line"> -connections int  </span><br><span class="line"> 指定每个目标主机打开的空闲连接的最大数目，默认值为 10000。  </span><br><span class="line"> -duration duration  </span><br><span class="line"> 指定发送请求到目标主机的时长，用 0 表示永久。  </span><br><span class="line"> -header value  </span><br><span class="line"> 指定目标的请求头，可以重复指定多个请求头。  </span><br><span class="line"> -http2  </span><br><span class="line"> 指定是否向支持的服务器发送 HTTP/2 请求，默认为：true。  </span><br><span class="line"> -insecure  </span><br><span class="line"> 指定是否忽略无效的服务器 TLS 证书。  </span><br><span class="line"> -keepalive  </span><br><span class="line"> 指定是否使用持久链接，默认值为：true。  </span><br><span class="line"> -key string  </span><br><span class="line"> 指定 HTTPS 请求中使用的 PEM 编码的 SSL 客户端证书私钥文件。  </span><br><span class="line"> -laddr value  </span><br><span class="line"> 指定要使用的本地 I P地址，默认值为：0.0.0.0。  </span><br><span class="line"> -lazy  </span><br><span class="line"> 指定是否使用延迟模式读取目标。  </span><br><span class="line"> -output string  </span><br><span class="line"> 指定输出文件的位置，默认为标准输出。  </span><br><span class="line"> -rate uint  </span><br><span class="line"> 指定每秒钟对目标发送的请求数，默认值为：50。  </span><br><span class="line"> -redirects int  </span><br><span class="line"> 指定每个请求的重定向的最大次数，默认为 10 次。当值为 -1, 不会遵循重定向但响应标记为成功。  </span><br><span class="line"> -root-certs value  </span><br><span class="line"> 指定可信的 TLS 根证书文件，多个的情况下使用逗号分隔。如果未指定，使用系统默认的 CA 证书。  </span><br><span class="line"> -targets string  </span><br><span class="line"> 指定目标文件，默认为标准输入。  </span><br><span class="line"> -timeout duration  </span><br><span class="line"> 指定每个请求的超时时间，默认值为 30s。  </span><br><span class="line"> -workers uint  </span><br><span class="line"> 指定初始化进程数量，默认值为 10。  </span><br><span class="line">  </span><br><span class="line">report command:  </span><br><span class="line"> -inputs string  </span><br><span class="line"> 指定报告输入文件，默认为标准输入。  </span><br><span class="line"> -output string  </span><br><span class="line"> 指定报告输出文件，默认为标准输出。  </span><br><span class="line"> -reporter string  </span><br><span class="line"> 指定要生成的报告的格式，支持 text，json, plot, hist[buckets]。默认为文本。  </span><br><span class="line">   </span><br><span class="line">dump command:  </span><br><span class="line"> -dumper string  </span><br><span class="line"> 指定转存文件，支持 json, csv 格式。默认为 json 格式。  </span><br><span class="line"> -inputs string  </span><br><span class="line"> 指定要转存的输入文件，默认为标准输入，指定多个用逗号分隔。  </span><br><span class="line"> -output string  </span><br><span class="line"> 指定要转存的输出文件，默认为标准输出。</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;GET http://www.baidu.com&quot; | vegeta attack -rate=50 -connections=1 -duration=1s | tee results.bin | vegeta report</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">tee houminxi.bin <span class="comment">#将vegeta的请求结果以二进制的格式保存起来。这个文件最主要的作用是如果你以后分布式执行压测，那么最后使用vegeta report统计结果的时候则需要使用每台压测机器上该文件。</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>rate : 每秒发送qing请求数</li>
<li>connection : 主机打开的空闲连接数</li>
<li>duration : 放松请求到主机的时长</li>
</ul>
<p>返回结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Requests      [total, rate, throughput]         50, 51.07, 49.21</span><br><span class="line">Duration      [total, attack, wait]             1.016s, 978.964ms, 37.086ms</span><br><span class="line">Latencies     [min, mean, 50, 90, 95, 99, max]  18.227ms, 51.221ms, 31.514ms, 116.864ms, 144.458ms, 240.26ms, 240.26ms</span><br><span class="line">Bytes In      [total, mean]                     17465200, 349304.00</span><br><span class="line">Bytes Out     [total, mean]                     0, 0.00</span><br><span class="line">Success       [ratio]                           100.00%</span><br><span class="line">Status Codes  [code:count]                      200:50</span><br><span class="line">Error Set:</span><br></pre></td></tr></table></figure>

<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>post请求要按照webserver所给出的格式来填写对应的路径和请求参数。vegeta提供-targets来读取你在文本内所定义的目标请求端。提供-body指定一个文件，该文件的内容将被设置为每个请求的主体，注意请求主题如果在body中指定了就不要在target的文件中指定了，否则会被target文件中的设置所覆盖。</p>
<ul>
<li><p>原始的curl命令调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;version&quot;:&quot;1.0&quot;,&quot;caller&quot;:&quot;DES&quot;,&quot;password&quot;:&quot;DES&quot;,&quot;callee&quot;:&quot;TDSQL&quot;,&quot;eventId&quot;:101,&quot;timestamp&quot;:1435749309,&quot;interface&quot;:&#123;&quot;interfaceName&quot;:&quot;TDSQL.GetInstance&quot;,&quot;para&quot;:&#123;&quot;instance&quot;:[&#123;&quot;id&quot;:&quot;set_1614047032_1141&quot;&#125;]&#125;&#125;&#125;&#x27; 9.30.1.233:8080/tdsql</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个<code>target.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://9.30.1.233:8080/tdsql</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个json <code>body.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line"> <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;1.0&quot;</span>,  </span><br><span class="line"> <span class="attr">&quot;caller&quot;</span>:<span class="string">&quot;DES&quot;</span>,  </span><br><span class="line"> <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;DES&quot;</span>,  </span><br><span class="line"> <span class="attr">&quot;callee&quot;</span>:<span class="string">&quot;TDSQL&quot;</span>,  </span><br><span class="line"> <span class="attr">&quot;eventId&quot;</span>:<span class="number">101</span>,  </span><br><span class="line"> <span class="attr">&quot;timestamp&quot;</span>:<span class="number">1435749309</span>,  </span><br><span class="line"> <span class="attr">&quot;interface&quot;</span>:&#123;  </span><br><span class="line">        <span class="attr">&quot;interfaceName&quot;</span>:<span class="string">&quot;TDSQL.GetInstance&quot;</span>,  </span><br><span class="line">        <span class="attr">&quot;para&quot;</span>:&#123;  </span><br><span class="line">            <span class="attr">&quot;instance&quot;</span>:[  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;set_1614047032_1141&quot;</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">            ]  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>vegeta命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vegeta -cpus 24 attack -targets target.txt -body body.json -timeout=20s -rate 500 -duration=10s | vegeta report</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Requests      [total, rate, throughput]         5000, 500.09, 487.50</span><br><span class="line">Duration      [total, attack, wait]             10.256s, 9.998s, 258.046ms</span><br><span class="line">Latencies     [min, mean, 50, 90, 95, 99, max]  36.38ms, 57.077ms, 51.602ms, 62.614ms, 70.48ms, 279.916ms, 1.124s</span><br><span class="line">Bytes In      [total, mean]                     705000, 141.00</span><br><span class="line">Bytes Out     [total, mean]                     1710000, 342.00</span><br><span class="line">Success       [ratio]                           100.00%</span><br><span class="line">Status Codes  [code:count]                      200:5000</span><br><span class="line">Error Set:</span><br></pre></td></tr></table></figure>

<p><code>Requests</code> :</p>
<ul>
<li>   <code>total</code>  : 全部的请求数量</li>
<li>  <code>rate</code> : 真正的每秒请求速率</li>
<li>  <code>throughput</code> : 整个周期期间成功的请求速率</li>
</ul>
<p><code>Duration</code> :</p>
<ul>
<li><code>attack</code> : 所有请求所用的时间(<code>total</code> - <code>wait</code>) </li>
<li><code>wait</code> : 等待最后一次发出请求响应的等待时间(<code>total</code> - <code>attack</code>)</li>
<li><code>total</code> : 总时间</li>
</ul>
<p><code>Latency</code> : </p>
<ul>
<li><code>min</code> : 所有请求中最小的延迟</li>
<li><code>mean</code> : 平均</li>
<li>50、90、95、99 分别是攻击中所有请求延迟的第 50、90、95 和 99 个百分位数。</li>
<li><code>max</code> : 最大的延迟</li>
</ul>
<p><code>Bytes In</code> &amp; <code>Bytes Out</code></p>
<ul>
<li>与请求或响应正文一起发送（输出）或接收（输入）的字节总数。</li>
</ul>
<p><code>Success</code></p>
<ul>
<li><code>ratio</code> : 成功率显示响应未出错且状态代码介于 200 和 400（不包括在内）之间的请求的百分比。</li>
</ul>
<p><code>Status Codes</code></p>
<ul>
<li>显示状态代码的直方图。 0 状态码表示请求发送失败。</li>
</ul>
<p><code>Error Set</code></p>
<ul>
<li>错误集显示所有发出的请求返回的一组唯一错误。 其中包括获得不成功响应状态代码的请求。</li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>vegeta</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>初识grpc和快速上手</title>
    <url>/2022/05/17/%E5%88%9D%E8%AF%86grpc%E5%92%8C%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<p>简单初步学习下grpc。</p>
<span id="more"></span>

<!-- toc -->
<h2 id="grpc的动机"><a href="#grpc的动机" class="headerlink" title="grpc的动机"></a>grpc的动机</h2><ul>
<li>不同语言之间的通行(前后端语言不同 )</li>
<li>更高效的通信 </li>
<li>更简单的通信 </li>
</ul>
<p> grpc是什么</p>
<ul>
<li>谷歌发明的rpc框架</li>
<li><strong>rpc</strong> （romote procedure calls ）</li>
</ul>
<h3 id="grpc如何工作的"><a href="#grpc如何工作的" class="headerlink" title="grpc如何工作的"></a>grpc如何工作的</h3><ul>
<li>客户端具有在服务器中提供相同方法的存根</li>
<li>使用<code>protocol buffer</code>生成代码（存根stub）</li>
</ul>
<h3 id="协议缓冲区（protocol-buffer）"><a href="#协议缓冲区（protocol-buffer）" class="headerlink" title="协议缓冲区（protocol buffer）"></a>协议缓冲区（protocol buffer）</h3><ul>
<li>可以生产多种语言的代码</li>
<li>传输速度更快，序列化程度高</li>
<li>客户端和服务器更强的链接</li>
<li>更好的api演化规则</li>
</ul>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>常用的微服务框架<br><img src="/2022/05/17/%E5%88%9D%E8%AF%86grpc%E5%92%8C%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220422231420347.png" title="微服务框架"><br>通过上述的架构，解决了单体架构的弊端。</p>
<p>但同时引入了新的问题：</p>
<ol>
<li> 代码冗余: 通过认证中心统一相同服务</li>
<li> 服务和服务之间存在调用关系: 通过rpc解决不同服务之间的通信问题</li>
</ol>
<p><img src="/2022/05/17/%E5%88%9D%E8%AF%86grpc%E5%92%8C%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220422233632635.png" title="注册中心"><br>服务治理中有一个重要的概念<code>服务发现</code>，服务发现中有一个重要的概念叫做<code>注册中心</code>。<br>每个服务启动的时候，会将自身的服务和ip注册到注册中心，其他服务调用的时候，只需要向注册中心申请地址即可。</p>
<h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><p>gRPC默认使用<code>protocol buffers</code>，这是google开源的一套成熟的结构数据序列化机制。</p>
<p><strong>序列化</strong>：将数据结构或对象转换成二进制串的过程。</p>
<p><strong>反序列化</strong>：将在序列化过程中所产生的二进制串转换成数据结构或对象的过程。</p>
<blockquote>
<p>如何使用protobuf呢？（1.写代码 2.编译）</p>
</blockquote>
<ol>
<li>定义了一种源文件，扩展名为 <code>.proto</code>，使用这种源文件，可以定义存储类的内容(消息类型)</li>
<li> protobuf有自己的编译器 <code>protoc</code>，可以将 <code>.proto</code> 编译成对应语言的文件，就可以进行使用了</li>
</ol>
<h3 id="proto编写"><a href="#proto编写" class="headerlink" title="proto编写"></a>proto编写</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定的当前proto语法的版本，有2和3</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">//option go_package = &quot;path;name&quot;; ath 表示生成的go文件的存放地址，会自动生成目录的</span></span><br><span class="line"><span class="comment">// name 表示生成的go文件所属的包名</span></span><br><span class="line"><span class="keyword">option</span> go_package=<span class="string">&quot;../service&quot;</span>;</span><br><span class="line"><span class="comment">// 指定等会文件生成出来的package</span></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">service</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">message</span> User </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译user.proto之后输出到service文件夹</span><br><span class="line">protoc --go_out=../service user.proto</span><br></pre></td></tr></table></figure>
<p>这里有两个坑:</p>
<ul>
<li><code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</code>使用这个命令拉去go的protoc编译器</li>
<li>环境变量添加``export PATH=$PATH:$GOPATH/bin</li>
</ul>
<p>使用<br>demo例子</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   user := &amp;service.User&#123;  </span><br><span class="line">      Username: <span class="string">&quot;enming&quot;</span>,  </span><br><span class="line">      Age:      <span class="number">18</span>,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 序列化  </span></span><br><span class="line">   marshal, err := proto.Marshal(user)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      fmt.Println(err)  </span><br><span class="line">      <span class="built_in">panic</span>(err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 反序列化  </span></span><br><span class="line">   oneUser := &amp;service.User&#123;&#125;  </span><br><span class="line">   err = proto.Unmarshal(marshal, oneUser)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      fmt.Println(err)  </span><br><span class="line">      <span class="built_in">panic</span>(err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Println(oneUser.String())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="proto语法"><a href="#proto语法" class="headerlink" title="proto语法"></a>proto语法</h3><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p><code>message</code>：<code>protobuf</code>中定义一个消息类型是通过关键字<code>message</code>字段指定的。<br>消息就是需要传输的数据格式的定义。<br>类似于c++的类</p>
<p>eg:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> password = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> address = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>required</code>:消息体中必填字段，不设置会导致编解码异常。（例如位置1）</li>
<li><code>optional</code>: 消息体中可选字段。（例如位置3）</li>
<li>  <code>repeated</code>: 消息体中可重复字段，重复的值的顺序会被保留（例如位置3）在go中重复的会被定义为切片。</li>
</ul>
<p><code>标识号</code>：在消息体的定义中，每个字段都必须要有一个唯一的标识号，标识号是[0,2^29-1]范围内的一个整数。</p>
<h4 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h4><p>如果想要将消息类型用在RPC系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer 编译器将会根据所选择的不同语言生成服务接口代码及存根。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//rpc 服务的函数名 （传入参数）返回（返回参数）</span></span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代表表示，定义了一个RPC服务，该方法接收SearchRequest返回SearchResponse</p>
<h2 id="grpc实例"><a href="#grpc实例" class="headerlink" title="grpc实例"></a>grpc实例</h2><p><a href="https://github.com/HannoKishi/grpc_demo">github代码</a><br><a href="https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code">官方参考实例</a></p>
<ul>
<li>生成一个服务器的proto</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// Sends another greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloAgain (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>坑:  提前安装插件和环境路径设置好</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>protoc --go-grpc_out=./ helloworld.proto</code> 生成接口的pb.go文件</li>
<li><code>protoc --go_out=./ helloworld.proto</code> 生成请求和返回的结构体的pb.go文件</li>
</ul>
<ul>
<li>实现这个接口的方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个是生成的 helloworld_grpc.pb.go里面的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//type GreeterServer interface &#123;  </span></span><br><span class="line"><span class="comment">// // Sends a greeting  </span></span><br><span class="line"><span class="comment">// SayHello(context.Context, *HelloRequest) (*HelloReply, error)  </span></span><br><span class="line"><span class="comment">// // Sends another greeting  </span></span><br><span class="line"><span class="comment">// SayHelloAgain(context.Context, *HelloRequest) (*HelloReply, error)  </span></span><br><span class="line"><span class="comment">// mustEmbedUnimplementedGreeterServer()  </span></span><br><span class="line"><span class="comment">//&#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现该接口的所有方法</span></span><br><span class="line"><span class="keyword">type</span> GreaterHandle <span class="keyword">struct</span> &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GreaterHandle)</span> <span class="title">SayHello</span><span class="params">(context context.Context, req *HelloRequest)</span> <span class="params">(*HelloReply, error)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;HelloReply&#123;Message: <span class="string">&quot;nihao&quot;</span>&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GreaterHandle)</span> <span class="title">SayHelloAgain</span><span class="params">(context context.Context, res *HelloRequest)</span> <span class="params">(*HelloReply, error)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;HelloReply&#123;Message: <span class="string">&quot;nihao too&quot;</span>&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GreaterHandle)</span> <span class="title">mustEmbedUnimplementedGreeterServer</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>服务器代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;google.golang.org/grpc&quot;</span>  </span><br><span class="line">   <span class="string">&quot;helloworld/service&quot;</span>   <span class="string">&quot;log&quot;</span>   <span class="string">&quot;net&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="comment">// 生成一个grpc的服务器  </span></span><br><span class="line">   server := grpc.NewServer()  </span><br><span class="line">   <span class="comment">// 向服务器注册接口和handle  </span></span><br><span class="line">   service.RegisterProdServiceServer(server, &amp;service.ProductService&#123;&#125;)  </span><br><span class="line">   service.RegisterGreeterServer(server, &amp;service.GreaterHandle&#123;&#125;)  </span><br><span class="line">   listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8002&quot;</span>)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatal(<span class="string">&quot;服务监听端口失败&quot;</span>, err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 服务器启动  </span></span><br><span class="line">   _ = server.Serve(listener)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;context&quot;</span>  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>   <span class="string">&quot;google.golang.org/grpc&quot;</span>   <span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span>   <span class="string">&quot;helloworld/service&quot;</span>   <span class="string">&quot;log&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="comment">// 1. 新建连接，端口是服务端开放的8002端口  </span></span><br><span class="line">   <span class="comment">// 没有证书会报错  </span></span><br><span class="line">   conn, err := grpc.Dial(<span class="string">&quot;:8002&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatal(err)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 退出时关闭链接  </span></span><br><span class="line">   <span class="keyword">defer</span> conn.Close()  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 2. 调用Product.pb.go中的NewProdServiceClient方法  </span></span><br><span class="line">   <span class="comment">// productServiceClient := service.NewProdServiceClient(conn)  </span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 3. 直接像调用本地方法一样调用GetProductStock方法  </span></span><br><span class="line">   <span class="comment">// resp, err := productServiceClient.GetProductStock(context.Background(), &amp;service.ProductRequest&#123;ProdId: 233&#125;)  </span></span><br><span class="line">   greeterClient := service.NewGreeterClient(conn)  </span><br><span class="line">   resp, err := greeterClient.SayHello(context.Background(), &amp;service.HelloRequest&#123;Name: <span class="string">&quot;i&quot;</span>&#125;)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatal(<span class="string">&quot;调用gRPC方法错误: &quot;</span>, err)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   fmt.Println(<span class="string">&quot;调用gRPC方法成功，ProdStock = &quot;</span>, resp.Message)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针与内存管理</title>
    <url>/2022/03/31/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>c++11/17/20新特性学习笔记</p>
<span id="more"></span>

<!-- toc -->
<h2 id="RAII-与引用计数"><a href="#RAII-与引用计数" class="headerlink" title="RAII 与引用计数"></a>RAII 与引用计数</h2><ul>
<li>什么是RAII？<br><code>RAII</code>是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。<br>而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序 员不再需要关心手动释放内存。这些智能指针就包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>， 使用它们需要包含头文件 <memory>。</li>
</ul>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p>std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete，当引用计数变为零的时候就会将对象自动删除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成shared指针</span></span><br><span class="line"><span class="comment">// 明确只向</span></span><br><span class="line"><span class="keyword">auto</span> p = std::shared_ptr&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 使用make_shared初始化</span></span><br><span class="line"><span class="keyword">auto</span> pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并 通过 use_count() 来查看一个对象的引用计数。</span></span><br><span class="line"><span class="keyword">auto</span> pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数 +1  </span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 引用计数 +1  </span></span><br><span class="line"><span class="keyword">int</span> *p = pointer.<span class="built_in">get</span>(); <span class="comment">// 这样不会增加引用计数  </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3 </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用reset来减少</span></span><br><span class="line">pointer2.<span class="built_in">reset</span>();  </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 0, pointer2 已 reset </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; pointer = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入 </span></span><br><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
<p>虽然是不可复制的指针，但是可以通过std::move将其转移给其他的unque_ptr</p>
<h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><h4 id="std-shared-ptr的循环引用问题"><a href="#std-shared-ptr的循环引用问题" class="headerlink" title="std::shared_ptr的循环引用问题"></a>std::shared_ptr的循环引用问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>  </span><br><span class="line">	std::shared_ptr&lt;B&gt; pointer; </span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; </span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">auto</span> a = std::make_shared&lt;A&gt;(); </span><br><span class="line">	<span class="keyword">auto</span> b = std::make_shared&lt;B&gt;(); </span><br><span class="line">	a-&gt;pointer = b;  </span><br><span class="line">	b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露。<br>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>, 弱引用不会引起引用计数增加。<br><code>std::weak_ptr</code> 没有 * 运算符和 -&gt; 运算符，所以不能够对资源进行操作，它的唯一作用就是用于 检查 <code>std::shared_ptr </code>是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true。</p>
]]></content>
      <categories>
        <category>语言学习</category>
        <category>c++</category>
        <category>现代c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器强化</title>
    <url>/2022/03/31/%E5%AE%B9%E5%99%A8%E5%BC%BA%E5%8C%96/</url>
    <content><![CDATA[<p>c++11/17/20新特性学习笔记</p>
<span id="more"></span>

<!-- toc -->
<h2 id="线性容器"><a href="#线性容器" class="headerlink" title="线性容器"></a>线性容器</h2><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><p>原因：std::array大小是固定的，而std::vector会自动扩容</p>
<p>使用 std::array 很简单，只需指定其类型和大小即可:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">arr.<span class="built_in">empty</span>(); <span class="comment">// 检查容器是否为空 arr.size(); // 返回容纳的元素数</span></span><br><span class="line"><span class="comment">// 迭代器支持  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用 lambda 表达式排序  </span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组大小参数必须是常量表达式  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> len = <span class="number">4</span>;  </span><br><span class="line">std::array&lt;<span class="keyword">int</span>, len&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>传统 C++ 中的有序容器 std::map/std::set， 内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。<br>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)在不关心容器内部元素顺序时，能够获得显著的性能提升。<br>c++11引入了 std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h4 id="元组基本操作"><a href="#元组基本操作" class="headerlink" title="元组基本操作"></a>元组基本操作</h4><p>关于元组的使用有三个核心的函数: </p>
<ol>
<li>std::make_tuple: 构造元组  </li>
<li>std::get: 获得元组某个位置的值 </li>
<li>std::tie: 元组拆包</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">0</span>)  </span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">3.8</span>, ’A’, <span class="string">&quot; 张三&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">1</span>)  </span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">2.9</span>, ’C’, <span class="string">&quot; 李四&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">2</span>)  </span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1.7</span>, ’D’, <span class="string">&quot; 王五&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0.0</span>, ’D’, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">	<span class="comment">// 如果只写 0 会出现推断错误, 编译失败 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元组拆包 </span></span><br><span class="line"><span class="keyword">double</span> gpa;</span><br><span class="line"><span class="keyword">char</span> grade;</span><br><span class="line">std::string name;</span><br><span class="line">std::<span class="built_in">tie</span>(gpa, grade, name) = <span class="built_in">get_student</span>(<span class="number">1</span>); </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span>  </span><br><span class="line">&lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span>  </span><br><span class="line">&lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span>  </span><br><span class="line">&lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; name &lt;&lt; ’\n’;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// get 拆包</span></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;123&quot;</span>, <span class="number">4.5</span>, <span class="number">6.7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;std::string&gt;(t) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; std::get&lt;double&gt;(t) &lt;&lt; std::endl; // 非法, 引发编译期错误</span></span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="运行期索引"><a href="#运行期索引" class="headerlink" title="运行期索引"></a>运行期索引</h3><p>std::get&lt;&gt; 依赖一个编译期的常量，因此下面的用法会导致编译错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不合理</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">std::get&lt;index&gt;(t);</span><br></pre></td></tr></table></figure>

<p>使用 std::variant&lt;&gt;(C++ 17 引入)，提供给 variant&lt;&gt; 的类型模板 参数可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量。</p>
<h3 id="元组合并与遍历"><a href="#元组合并与遍历" class="headerlink" title="元组合并与遍历"></a>元组合并与遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元组合并</span></span><br><span class="line"><span class="keyword">auto</span> new_tuple = std::<span class="built_in">tuple_cat</span>(<span class="built_in">get_student</span>(<span class="number">1</span>), std::<span class="built_in">move</span>(t));</span><br><span class="line"><span class="comment">// 运行期通过非常数索引 一个 tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::tuple_size&lt;T&gt;::value; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="built_in">tuple_len</span>(new_tuple); ++i)</span><br><span class="line"><span class="comment">// 运行期索引  </span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">tuple_index</span>(i, new_tuple) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语言学习</category>
        <category>c++</category>
        <category>现代c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式&amp;并行并发&amp;杂项</title>
    <url>/2022/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>c++11/17/20新特性学习笔记</p>
<span id="more"></span>

<!-- toc -->
<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>而 C++11 正式将正则表达式的的处理方法纳入 标准库的行列，从语言级上提供了标准的支持，不再依赖第三方。</p>
<p>C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生std::smatch(本质是 std::match_results 对象)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，</span></span><br><span class="line"><span class="function">std::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line">	std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">regex_match</span>(fname, txt_regex) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::smatch 可以方便的对匹配的结果进行获取</span></span><br><span class="line"><span class="function">std::regex <span class="title">base_regex</span><span class="params">(<span class="string">&quot;([a-z]+)\\.txt&quot;</span>)</span></span>; </span><br><span class="line">std::smatch base_match;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames) &#123;</span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(fname, base_match, base_regex)) &#123; </span><br><span class="line">	<span class="comment">// std::smatch 的第一个元素匹配整个字符串  </span></span><br><span class="line">	<span class="comment">// std::smatch 的第二个元素匹配了第一个括号表达式  </span></span><br><span class="line">	<span class="keyword">if</span> (base_match.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">		std::string base = base_match[<span class="number">1</span>].<span class="built_in">str</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;sub-match[0]: &quot;</span> &lt;&lt; base_match[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot; sub-match[1]: &quot;</span> &lt;&lt; base &lt;&lt; std::endl; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">foo.txt: <span class="number">1</span></span><br><span class="line">bar.txt: <span class="number">1</span></span><br><span class="line">test: <span class="number">0</span></span><br><span class="line">a0.txt: <span class="number">0</span></span><br><span class="line">AAA.txt: <span class="number">0</span></span><br><span class="line">sub-match[<span class="number">0</span>]: foo.txt</span><br><span class="line">foo.txt sub-match[<span class="number">1</span>]: foo</span><br><span class="line">sub-match[<span class="number">0</span>]: bar.txt</span><br><span class="line">bar.txt sub-match[<span class="number">1</span>]: bar</span><br></pre></td></tr></table></figure>

<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><h3 id="并行基础"><a href="#并行基础" class="headerlink" title="并行基础"></a>并行基础</h3><p>c++11开始提供了std::thread类</p>
<h3 id="互斥量与临界区"><a href="#互斥量与临界区" class="headerlink" title="互斥量与临界区"></a>互斥量与临界区</h3><p>通过实例化 std::mutex 可以创建互斥量，而通过 其成员函数 lock() 可以进行上锁，unlock() 可以进行解锁。但是在在实际编写代码的过程中，最好不 去直接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异 常。这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类<code> std::lock_guard</code>。RAII 在不失代码简 洁性的同时，很好的保证了代码的异常安全性。</p>
<ul>
<li><code>std::lock_guard</code> : </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critical_section</span><span class="params">(<span class="keyword">int</span> change_v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> std::mutex mtx;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; </span><br><span class="line">	<span class="comment">// 执行竞争操作 </span></span><br><span class="line">	v = change_v;</span><br><span class="line">	<span class="comment">// 离开此作用域后 mtx 会被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 C++ 保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码也是异常安全的。无论 critical_section() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。</p>
<ul>
<li><code>std::unique_lock</code> :<br>std::unique_lock 则 相 对 于 std::lock_guard 出 现 的，std::unique_lock 更 加 灵 活， std::unique_lock 的对象会以独占所有权(没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权)的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。</li>
</ul>
<p>std::lock_guard 不能显式的调用 lock 和 unlock，而 <strong>std::unique_lock 可以在声明后的任意位置调用</strong>，可以缩小锁的作用范围，提供更高的并发度。</p>
<p>如果你用到了条件变量 std::condition_variable::wait 则<strong>必须</strong>使用 std::unique_lock 作为参 数。因为条件变量的wait要先解锁，而只有std::unique_lock才有解锁功能。</p>
<h3 id="期物（Future）"><a href="#期物（Future）" class="headerlink" title="期物（Future）"></a>期物（Future）</h3><p>期物(Future)表现为 std::future，它提供了一个访问异步操作结果的途径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个返回值为 7 的 lambda 表达式封装到 task 中  </span></span><br><span class="line"><span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line"><span class="comment">// 获得 task 的期物</span></span><br><span class="line">std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障，阻塞到期物的完成</span></span><br><span class="line"><span class="comment">// 输出执行结果</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量 std::condition_variable 是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程 可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临 界区使得条件为真时，就会发生死锁。</p>
<h3 id="原子操作与内存模型"><a href="#原子操作与内存模型" class="headerlink" title="原子操作与内存模型"></a>原子操作与内存模型</h3><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>std::mutex 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能，这是因为一个互 斥锁的实现通常包含两条基本原理:</p>
<ul>
<li> 提供线程间自动的状态转换，即『锁住』这个状态</li>
<li> 保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离</li>
</ul>
<p>这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令(我们之 后再来看如何实现一个简单的互斥锁)。这对于一个仅需原子级操作(没有中间态)的变量，似乎太苛刻了。</p>
<p>在现代 CPU 体 系结构下提供了 CPU 指令级的原子操作，因此在 C++11 中多线程下共享变量的读写这一问题上，还引 入了 <code>std::atomic</code> 模板，使得我们实例化一个原子类型，将一个原子类型读写操作从一组指令，最小化 到单个 CPU 指令。<br><code>std::atomic&lt;int&gt; counter;</code><br>包括 fetch_add, fetch_sub等，同时通过重载方便的提供了对应的 +，- 版本。</p>
<ul>
<li>例子: </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123; </span></span></span><br><span class="line"><span class="params"><span class="function">	count.fetch_add(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	count++; </span></span></span><br><span class="line"><span class="params"><span class="function">	count += <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 等价于 fetch_add // 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;  </span><br><span class="line">t1.<span class="built_in">join</span>();  </span><br><span class="line">t2.<span class="built_in">join</span>();  </span><br><span class="line">std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>四种不同的一致性模型: </p>
<ul>
<li>线性一致性:<ul>
<li>又称强一致性或原子一致性，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</li>
</ul>
</li>
<li>顺序一致性:<ul>
<li>同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的 顺序一致。</li>
</ul>
</li>
<li>因果关系一致性: <ul>
<li>它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作 顺序则不做要求。</li>
</ul>
</li>
<li>最终一致性:<ul>
<li> 是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并 未要求被观察到的时间。</li>
</ul>
</li>
</ul>
<h3 id="C-的内存顺序"><a href="#C-的内存顺序" class="headerlink" title="C++的内存顺序"></a>C++的内存顺序</h3><p>C++11 为原子操作定义了六种不同的内存顺序 std::memory_order 的选项，表达了四种多线程间的同步模型。</p>
<ul>
<li><p>宽松模型:  在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。<br><code>counter.fetch_add(1, std::memory_order_relaxed);</code></p>
</li>
<li><p>释放/消费模型:  如果某个线程需要修改某个值，但 另一个线程会对该值的某次操作产生依赖，即后者<code>依赖</code>前者。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者生产</span></span><br><span class="line">ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line"><span class="comment">// 消费者消费</span></span><br><span class="line">ptr.<span class="built_in">load</span>(std::memory_order_consume)</span><br></pre></td></tr></table></figure></li>
<li><p>释放/获取模型<br>在释放 std::memory_order_release 和获取 std::memory_order_acquire 之间规定时序，即发生在释放 操作之前的所有写操作，对其他线程的任何获取操作都是可见的，亦即发生顺序(happens-before)。<br>std::memory_order_release 确保了它之后的写行为不会发生在释放操作之前。是一个向前的屏障<br>std::memory_order_acquire 确保了它之前的写行为，不会发生在该获取操作 之后，是一个向后的屏障<br>std::memory_order_acq_rel 而言，则结合了这两者的特点， 唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排到此操作的前后。</p>
</li>
<li><p>顺序一致性模型<br>在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 std::memory_order_seq_cst 进行指定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><h3 id="新类型"><a href="#新类型" class="headerlink" title="新类型"></a>新类型</h3><h4 id="long-long-int"><a href="#long-long-int" class="headerlink" title="long long int"></a>long long int</h4><p>C++11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。</p>
<h3 id="noexcept-的修饰和操作"><a href="#noexcept-的修饰和操作" class="headerlink" title="noexcept 的修饰和操作"></a>noexcept 的修饰和操作</h3><ul>
<li>C++11 将异常的声明简化为以下两种情况:</li>
</ul>
<ol>
<li><p>函数可能抛出任何异常</p>
</li>
<li><p>函数不能抛出任何异常<br>并使用 noexcept 对这两种行为进行限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">may_throw</span><span class="params">()</span></span>; <span class="comment">// 可能抛出异常  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 不可能抛出异常</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。</p>
<p>noexcept 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::boolalpha  </span><br><span class="line">&lt;&lt; <span class="string">&quot;may_throw() noexcept? &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">noexcept</span></span>(<span class="built_in">may_throw</span>()) &lt;&lt; std::endl</span><br></pre></td></tr></table></figure>
<p>noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><h4 id="原始字符串字面量"><a href="#原始字符串字面量" class="headerlink" title="原始字符串字面量"></a>原始字符串字面量</h4><p>C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时，将原始字符串使用括号包裹</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">R&quot;(C:\File\To\Path)&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="自定义字面量"><a href="#自定义字面量" class="headerlink" title="自定义字面量"></a>自定义字面量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字符串字面量自定义必须设置如下的参数列表  </span><br><span class="line">std::string operator&quot;&quot; _wow1(const char *wow1, size_t len) &#123;</span><br><span class="line">	return std::string(wow1)+&quot;woooooooooow, amazing&quot;; </span><br><span class="line">&#125;</span><br><span class="line">std::string operator&quot;&quot; _wow2 (unsigned long long i) &#123; </span><br><span class="line">	return std::to_string(i)+&quot;woooooooooow, amazing&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 相当于重载了_wow1和_wow2</span><br><span class="line">// 调用</span><br><span class="line">int main() &#123;  </span><br><span class="line">	auto str = &quot;abc&quot;_wow1;  </span><br><span class="line">	auto num = 1_wow2;  </span><br><span class="line">	std::cout &lt;&lt; str &lt;&lt; std::endl; </span><br><span class="line">	std::cout &lt;&lt; num &lt;&lt; std::endl; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>C++ 11 引入了两个新的关键字<code> alignof</code> 和 <code>alignas</code> 来支持对内存对齐进行控制。</p>
<p><code>alignof</code> 关键字 能够获得一个与平台相关的 std::size_t 类型的值，用于查询该平台的对齐方式。</p>
<p>C++ 11 还引入了 <code>alignas</code> 来重新修饰某个结构 的对齐方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Storage</span> &#123;</span> </span><br><span class="line">	<span class="keyword">char</span> a; </span><br><span class="line">	<span class="keyword">int</span> b; </span><br><span class="line">	<span class="keyword">double</span> c; </span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(std::<span class="keyword">max_align_t</span>)</span> AlignasStorage </span>&#123; </span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>      b;</span><br><span class="line">	<span class="keyword">double</span>   c;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> d; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	std::cout &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(Storage) &lt;&lt; std::endl; </span><br><span class="line">	std::cout &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(AlignasStorage) &lt;&lt; std::endl; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>std::max_align_t</code> 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 long double，因此我们这里得到的 AlignasStorage 的对齐要求是 8 或 16。</p>
]]></content>
      <categories>
        <category>语言学习</category>
        <category>c++</category>
        <category>现代c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>语言可用性</title>
    <url>/2022/03/27/%E8%AF%AD%E8%A8%80%E5%8F%AF%E7%94%A8%E6%80%A7/</url>
    <content><![CDATA[<p>c++11/17/20新特性学习笔记</p>
<span id="more"></span>

<!-- toc -->
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东 西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义 为 0。</p>
<p>为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型 为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">0</span>);  <span class="comment">// 调用 foo(int)</span></span><br><span class="line"><span class="comment">// foo(NULL); // 该行不能通过编译 // 调用 foo(char*)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="literal">nullptr</span>); <span class="comment">// 调用 foo(char*)</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line"><span class="comment">// char arr_4[len_2];   // 非法</span></span><br><span class="line"><span class="keyword">char</span> arr_4[len_2_constexpr]; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p>C++ 标准中数组的长度必须是一个常量表达式，而对 于 len_2 而言，这是一个 const 常数，而不是一个常量表达式。<br>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这 个关键字明确的告诉编译器应该去验证 len_foo 在编译期就应该是一个常量表达式。</p>
<h2 id="变量及其初始化"><a href="#变量及其初始化" class="headerlink" title="变量及其初始化"></a>变量及其初始化</h2><h3 id="if-switch-变量声明强化"><a href="#if-switch-变量声明强化" class="headerlink" title="if/switch 变量声明强化"></a>if/switch 变量声明强化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 将临时变量放到 if 语句内  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">	*itr = <span class="number">4</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++17 允许在if/switch里面定义临时变量了</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list， 允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初 始化方法提供了统一的桥梁。</p>
<figure class="highlight c++"><figcaption><span>下面这种构造函数也会调用初始化列表的方法初始化</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; list)&#123;</span><br><span class="line">		<span class="keyword">for</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt;::iterator it=list.<span class="built_in">begin</span>();it!=list.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();  </span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>c++17 新结构体 tuple允许返回多值</p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。</p>
<p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">int</span>&gt;::value) </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>其中，std::is_same&lt;T, U&gt; 用于判断 T 和 U 这两个类型是否相等。</p>
<h3 id="关于返回类型推导"><a href="#关于返回类型推导" class="headerlink" title="关于返回类型推导"></a>关于返回类型推导</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; R <span class="title">add</span><span class="params">(T x, U y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y) <span class="comment">// 错误写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++11 正确写法， 尾返回类型(trailing return type)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;  </span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">add2</span>(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y)&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c++14 写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++14开始可以直接使用auto，而不需要尾返回类型确认。</p>
<h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><p>简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。<br>语言运行时强化时候(<em><strong>回头再来看</strong></em>)</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p>C++17 将 <code>constexpr</code> 这个关键字引入到 if 语句中，允许在代码中声明常量 表达式的判断条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for的区间迭代"><a href="#for的区间迭代" class="headerlink" title="for的区间迭代"></a>for的区间迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x: vec)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p>
<h3 id="外部模版"><a href="#外部模版" class="headerlink" title="外部模版"></a>外部模版</h3><p>模板只有在使用时才会被编译器实例化。<br>换句话说，只要在每个编译单元(文件)中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。<br>c++11显式的通知编译器何时进行模板的实例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:vector&lt;<span class="keyword">bool</span>&gt;; <span class="comment">// 强行实例化  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:vector&lt;<span class="keyword">double</span>&gt;; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure>

<h3 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h3><p>在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一 个新的名称。因为，模板不是类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;   <span class="comment">// 函数指针阅读起来真的困难</span></span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">void</span> *);  </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;</span><br></pre></td></tr></table></figure>
<p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效</p>
<h3 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h3><p>c++11开始可以指定默认模版参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt; <span class="keyword">auto</span> <span class="built_in">add</span>(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x+y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Call add function </span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="keyword">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解包方式:</p>
<ul>
<li> 递归模板函数</li>
<li>变参模版展开</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt; <span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; t0 &lt;&lt; std::endl; </span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++17支持便餐模版展开</p>
<h3 id="非类型模板参数推导"><a href="#非类型模板参数推导" class="headerlink" title="非类型模板参数推导"></a>非类型模板参数推导</h3><p>前面我们主要提及的是模板参数的一种形式:类型模板参数。<br>非类型模板参数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> BufSize&gt; <span class="class"><span class="keyword">class</span> <span class="title">buffer_t</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> T data[BufSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在这种模板参数形式下，我们可以将 100 作为模板的参数进行传递</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 甚至可以让编译器推导类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl; </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函 数，从而达到简化代码的目的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Base</span>() &#123; </span><br><span class="line">	value1 = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Base</span>(<span class="keyword">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数 value2 = value;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="显示虚函数重载"><a href="#显示虚函数重载" class="headerlink" title="显示虚函数重载"></a>显示虚函数重载</h3><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>  </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里显示重载了虚函数</span></span><br></pre></td></tr></table></figure>

<p>C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。<br>override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>  </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> final final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>  </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="keyword">final</span>:</span> Base &#123; &#125;; <span class="comment">// 合法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123; &#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h3><p>如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值 算符以及析构函数。<br>c++11 提供了方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Magic</span>() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造  </span></span><br><span class="line">	Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造 </span></span><br><span class="line">	<span class="built_in">Magic</span>(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p> C++11 引入了枚举类(enumeration class)，并使用 enum class 的语法进行声明:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123; </span><br><span class="line">  value1,</span><br><span class="line"> value2,</span><br><span class="line"> value3 = <span class="number">100</span>,</span><br><span class="line"> value4 = <span class="number">100</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语言学习</category>
        <category>c++</category>
        <category>现代c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的list实现</title>
    <url>/2022/05/24/golang%E7%9A%84list%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在leetcode刷题时候，会用到链表的数据结构。在go语言中，链表的实现是有现成的接口的。</p>
<span id="more"></span>

<!-- toc -->

<p>在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。</p>
<ul>
<li><code>container/list</code>包中导入<br>list 包实现了一个双链表（doubly linked list）。<h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2>Element 用于代表双链表的元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">    next, prev *Element</span><br><span class="line">    list       *List</span><br><span class="line">    <span class="comment">// any 是接口类型</span></span><br><span class="line">    Value      any</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// Next returns the next list element or nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Element</span></span></span><br></pre></td></tr></table></figure>

<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>List 用于表示双链表。<br>空列表可以用作 List 的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">    root Element</span><br><span class="line">    <span class="built_in">len</span>  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部添加, 返回element</span></span><br><span class="line">    e1 := l.PushBack(<span class="string">&quot;canon&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头部添加</span></span><br><span class="line">    e2 := l.PushFront(<span class="number">67</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">    element := l.PushBack(<span class="string">&quot;fist&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fist之后添加high</span></span><br><span class="line">    l.InsertAfter(<span class="string">&quot;high&quot;</span>, element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fist之前添加noon</span></span><br><span class="line">    l.InsertBefore(<span class="string">&quot;noon&quot;</span>, element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除指定元素, 返回value</span></span><br><span class="line">    l.Remove(element)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ----- 遍历 ------</span></span><br><span class="line">	<span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">	    fmt.Println(i.Value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>存储与检索</title>
    <url>/2022/06/01/%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<p>设计数据密集型应用程序，一些常用的存储引擎与索引。</p>
<span id="more"></span>

<!-- toc -->

<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>键值存储与在大多数编程语言中可以找到的字典(dictionary)类型非常相似，通常字典都是 用散列映射(hash map)(或哈希表(hash table))实现的。<br>那么最简单的索引策 略就是:保留一个内存中的哈希映射，其中每个键都映射到一个数据文件中的字节偏移量， 指明了可以找到对应值的位置。</p>
<p>ps: 追加写入（追加和分段合并是顺序写入操作，通常比随机写入快得多），而不是删除原先的键值。</p>
<p>但是，哈希表索引也有局限性:</p>
<ul>
<li><p>散列表必须能放进内存</p>
<p>  如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是 磁盘哈希映射很难表现优秀。它需要大量的随机访问I/O，当它变满时增长是很昂贵的， 并且散列冲突需要很多的逻辑【5】。</p>
</li>
<li><p>范围查询效率不高。</p>
<p>  例如，您无法轻松扫描kitty00000和kitty99999之间的所有键——您 必须在散列映射中单独查找每个键。</p>
</li>
</ul>
<h2 id="SSTables（Sorted-String-Table）排序字符串表"><a href="#SSTables（Sorted-String-Table）排序字符串表" class="headerlink" title="SSTables（Sorted String Table）排序字符串表"></a>SSTables（Sorted String Table）排序字符串表</h2><p>SSTable 文件用于 Bigtable 内部数据存储。SSTable 文件是一个排序的、不可变的、持久化的 map 结构，其中 map 的 key-value 都可以是任意字节的字符串。支持使用指定键来查找值，或通过给定键范围遍历所有的 key-value 对。</p>
<p><img src="/2022/06/01/%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/sstable.png" title="内存索引的sstable"></p>
<p>工作方式: </p>
<ul>
<li>写入时，将其添加到内存中的平衡树数据结构(例如，红黑树)。这个内存树有时被称 为内存表(memtable)</li>
<li>当内存表大于某个阈值(通常为几兆字节)时，将其作为SSTable文件写入磁盘。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。</li>
<li>为了提供读取请求，<code>首先</code>尝试在内存表中找到关键字，<code>然后</code>在最近的磁盘段中，<code>然后</code>在 下一个较旧的段中找到该关键字。</li>
<li>有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。</li>
</ul>
<p>这种就是常说的<strong>LSM树</strong>（Log Structured Merge Tree，结构化合并<strong>树</strong>）</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="/2022/06/01/%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/b%E6%A0%91.png" title="b树"></p>
<p>B树将数据库分解成固定大小的块或页面，传统上大 小为4KB(有时会更大)，每个页面都可以使用地址或位置来标识，这允许一个页面引用另一个页面 —— 类似于指针， 但在磁盘而不是在内存中。<br>一个页面会被指定为B树的根;在索引中查找一个键时，就从这里开始。该页面包含几个键和 对子页面的引用。每个子页面负责一段连续范围的键，引用之间的键，指明了引用子页面的 键范围。</p>
<p>工作方式:</p>
<ul>
<li>如果要更新B树中现有键的值，则搜索包含该键的叶页，更改该页中的值，并将该页写回到磁 盘(对该页的任何引用保持有效) 。</li>
<li>如果你想添加一个新的键，你需要找到其范围包含新键 的页面，并将其添加到该页面。如果页面中没有足够的可用空间容纳新键，则将其分成两个 半满页面，并更新父页面以解释键范围的新分区</li>
</ul>
<h2 id="比较B树和LSM树"><a href="#比较B树和LSM树" class="headerlink" title="比较B树和LSM树"></a>比较B树和LSM树</h2><p>根据经验，通 常LSM树的写入速度更快，而B树的读取速度更快。 LSM树上的读取通常比较慢，因 为它们必须在压缩的不同阶段检查几个不同的数据结构和SSTables。</p>
<h3 id="LSM树的优点"><a href="#LSM树的优点" class="headerlink" title="LSM树的优点"></a>LSM树的优点</h3><p>b树写数据至少两次: 1. 一次预先写入日志 2. 一次写入树本身（还有可能会分页）即使在该页面中只有几个字节发生了变化，也需要一次编写整个页面的开销。</p>
<ul>
<li>写速度突出<ul>
<li>LSM树通常能够比B树支持更高的写入吞吐量，部分原因是它们有时具有较低的写放大 (尽管这取决于存储引擎配置和工作负载)，部分是因为它们顺序地写入紧凑的SSTable文件 而不是必须覆盖树中的几个页面。顺序写入 比随机写入快得多。</li>
</ul>
</li>
<li>磁盘利用率高<ul>
<li>LSM树可以被压缩得更好，因此经常比B树在磁盘上产生更小的文件。 B树存储引擎会由于分 割而留下一些未使用的磁盘空间:当页面被拆分或某行不能放入现有页面时，页面中的某些 空间仍未被使用。由于LSM树不是面向页面的，并且定期重写SSTables以去除碎片，所以它 们具有较低的存储开销，特别是当使用平坦压缩时</li>
</ul>
</li>
</ul>
<h3 id="LSM的缺点"><a href="#LSM的缺点" class="headerlink" title="LSM的缺点"></a>LSM的缺点</h3><ul>
<li>日志结构存储的缺点是压缩过程有时会干扰正在进行的读写操作。尽管存储引擎尝试逐步执 行压缩而不影响并发访问，但是磁盘资源有限，所以很容易发生请求需要等待而磁盘完成昂 贵的压缩操作。</li>
<li>压缩的另一个问题出现在高写入吞吐量:磁盘的有限写入带宽需要在初始写入(记录和刷新内存表到磁盘)和在后台运行的压缩线程之间共享。</li>
<li>如果写入吞吐量很高，并且压缩没有仔细配置，压缩跟不上写入速率。在这种情况下，磁盘 上未合并段的数量不断增加，直到磁盘空间用完，读取速度也会减慢，因为它们需要检查更 多段文件。</li>
</ul>
<p>B树的优点：在许多关系数据库中，事务隔离是通过在键范围上使用锁来实现的，在B树索引中，这些 锁可以直接连接到树。（B树的索引只有唯一的一个，而日志结构化存储引擎则可能在不同的段中有相同的副本）</p>
<h2 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h2><h3 id="值存在索引中"><a href="#值存在索引中" class="headerlink" title="值存在索引中"></a>值存在索引中</h3><ul>
<li>索引中的关键字是查询搜索的内容，但是该值可以是以下两种情况之一:它可以是所讨论的 实际行(文档，顶点)，也可以是对存储在别处的行的引用。行被存储的 地方被称为堆文件(heap file)，并且存储的数据没有特定的顺序。</li>
<li>将索引行直接存储在索引中。这被称为<code>聚集索引</code>。例如，在MySQL的InnoDB存储引擎中，表的主键 总是一个聚簇索引。</li>
<li>在<code>聚集索引(clustered index)</code>(在索引中存储所有行数据)和<code>非聚集索引(nonclustered index)</code>(仅在索引中存储对数据的引用)之间的折衷被称为包含列的索引(index with included columns)或<code>覆盖索引(covering index)</code>，其存储表的一部分在索引内。</li>
</ul>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><ul>
<li><code>连接索引(concatenated index)</code>，它通过将一列的值追加到另一 列后面，简单地将多个字段组合成一个键(索引定义中指定了字段的连接顺序)。</li>
<li><code>多维索引(multi-dimensional index)</code>是一种查询多个列的更一般的方法，这对于地理空间 数据尤为重要。(扩展到R树)</li>
</ul>
<h3 id="全文搜索和模糊索引"><a href="#全文搜索和模糊索引" class="headerlink" title="全文搜索和模糊索引"></a>全文搜索和模糊索引</h3><h3 id="事务处理与分析"><a href="#事务处理与分析" class="headerlink" title="事务处理与分析"></a>事务处理与分析</h3><p>即使数据库开始被用于许多不同类型的博客文章，游戏中的动作，地址簿中的联系人等等， 基本访问模式仍然类似于处理业务事务。应用程序通常使用索引通过某个键查找少量记录。 根据用户的输入插入或更新记录。由于这些应用程序是交互式的，因此访问模式被称为在线 事务处理(OLTP, OnLine Transaction Processing)。</p>
<p>这些查询通常由业务分析师编写，并提供给帮助公司管理层做出更好决策(商业智能)的报 告。为了区分这种使用数据库的事务处理模式，它被称为在线分析处理(OLAP, OnLine Analytice Processing)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>OLTP系统通常面向用户，这意味着他们可能会看到大量的请求。为了处理负载，应用程 序通常只触及每个查询中的少量记录。应用程序使用某种键来请求记录，存储引擎使用 索引来查找所请求的键的数据。磁盘寻道时间往往是这里的瓶颈。 </li>
<li>OLAP数据仓库和类似的分析系统不太知名，因为它们主要由业务分析人员使用，而不是由最 终用户使用。它们处理比OLTP系统少得多的查询量，但是每个查询通常要求很高，需要 在短时间内扫描数百万条记录。磁盘带宽(不是查找时间)往往是瓶颈，列式存储是这 种工作负载越来越流行的解决方案。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计数据密集型应用程序</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>go的切片和指针</title>
    <url>/2022/06/17/go%E7%9A%84%E5%88%87%E7%89%87%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。<strong>切片本身是一个只读对象，其工作机制类似数组指针的一种封装</strong>。</p>
<span id="more"></span>
<!-- toc -->

<p>[toc]</p>
<p><a href="https://halfrost.com/go_slice/">参考文章</a></p>
<h2 id="go语言指针"><a href="#go语言指针" class="headerlink" title="go语言指针"></a>go语言指针</h2><p>Go中的指针及与指针对指针的操作主要有以下三种：</p>
<ul>
<li><p>一普通的指针类型，例如 var intptr *T，定义一个T类型指针变量。</p>
</li>
<li><p>二内置类型uintptr，本质是一个无符号的整型，它的长度是跟平台相关的，它的长度可以用来保存一个指针地址。</p>
</li>
<li><p>三是unsafe包提供的Pointer，表示可以指向任意类型的指针。</p>
</li>
</ul>
<h3 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h3><p>通过引用来修改值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := <span class="number">1</span></span><br><span class="line">Counter(&amp;count)</span><br><span class="line">fmt.Println(count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Counter</span><span class="params">(count *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h3><p>uintptr用来进行指针计算，因为它是整型，所以很容易计算出下一个指针所指向的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// uintptr is an integer type that is large enough to hold the bit pattern of  </span></span><br><span class="line"><span class="comment">// any pointer. </span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">uintptr</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg:</span></span><br><span class="line">n := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>;i&lt; n;i++ &#123;</span><br><span class="line">    b[i] = i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取slice的最后的一个元素 做offset位移</span></span><br><span class="line">end := unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="number">9</span> * unsafe.Sizeof(b[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">// 等价于unsafe.Pointer(&amp;b[9])</span></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(end))</span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>注意：虽然uintpr保存了一个指针地址，但它只是一个值，不引用任何对象。</p>
<ul>
<li>如果uintptr地址相关联对象移动，则其值也不会更新。例如goroutine的堆栈信息发生变化</li>
<li>uintptr地址关联的对象可以被垃圾回收。GC不认为uintptr是活引用，<strong>因此unitptr地址指向的对象可以被垃圾收集。</strong></li>
</ul>
<p>一个uintptr可以被转换成unsafe.Pointer,同时unsafe.Pointer也可以被转换为uintptr。可以使用使用uintptr + offset计算出地址，然后使用unsafe.Pointer进行转换，格式如下：<code>p = unsafe.Pointer(uintptr(p) + offset)</code></p>
<p><strong>总结</strong>：<em><strong>uintptr</strong></em>指针用来做数学运算</p>
<h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p>unsafe.Pointer是特别定义的一种指针类型,它可以包含任意类型变量的地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArbitraryType is here for the purposes of documentation only and is not actually</span></span><br><span class="line"><span class="comment">// part of the unsafe package. It represents the type of an arbitrary Go expression.</span></span><br><span class="line"><span class="comment">// ArbitraryType在这里不是unsafe包的实际的一部分，仅仅是为了文档记录</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="comment">// 官方文档</span></span><br><span class="line">Pointer represents a pointer to an arbitrary <span class="keyword">type</span>. There are four special operations</span><br><span class="line">available <span class="keyword">for</span> <span class="keyword">type</span> Pointer that are not available <span class="keyword">for</span> other types:    <span class="comment">//  Pointer代表了一个任意类型的指针。Pointer类型有四种特殊的操作是其他类型不能使用的:</span></span><br><span class="line">   - A pointer value of any <span class="keyword">type</span> can be converted to a Pointer.       <span class="comment">//  任意类型的指针可以被转换为Pointer</span></span><br><span class="line">   - A Pointer can be converted to a pointer value of any <span class="keyword">type</span>.       <span class="comment">//  Pointer可以被转换为任务类型的值的指针</span></span><br><span class="line">   - A <span class="keyword">uintptr</span> can be converted to a Pointer.                         <span class="comment">//  uintptr可以被转换为Pointer</span></span><br><span class="line">   - A Pointer can be converted to a <span class="keyword">uintptr</span>.                         <span class="comment">//  Pointer可以被转换为uintptr</span></span><br><span class="line">Pointer therefore allows a program to defeat the <span class="keyword">type</span> system and read and write</span><br><span class="line">arbitrary memory. It should be used with extreme care.                <span class="comment">//  因此Pointer允许程序不按类型系统的要求来读写任意的内存，应该非常小心地使用它。</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：所以<code>unsafe.Pointer</code>做的主要是用来进行桥接，用于不同类型的指针进行互相转换。</p>
<h3 id="unsafe-Pointer-uintptr与普通指针的互相转换"><a href="#unsafe-Pointer-uintptr与普通指针的互相转换" class="headerlink" title="unsafe.Pointer,uintptr与普通指针的互相转换"></a>unsafe.Pointer,uintptr与普通指针的互相转换</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">1.0</span></span><br><span class="line">fmt.Println(Float64bits(f))</span><br><span class="line"><span class="comment">// 4607182418800017408</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">	<span class="comment">// (*uint64*) 转换成uint64指针 在*号取值</span></span><br><span class="line">    <span class="keyword">return</span> *((*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;f)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="go中常用的常量"><a href="#go中常用的常量" class="headerlink" title="go中常用的常量"></a>go中常用的常量</h2><ul>
<li><strong>^uintptr(0)</strong>:<ul>
<li>math.MaxUint64</li>
<li>2 的 64 次方减 1</li>
</ul>
</li>
<li><strong>maxAlloc</strong>:<ul>
<li><strong>允许用户分配的最大虚拟内存空间</strong>。在 64 位，理论上可分配最大 <code>1 &lt;&lt; heapAddrBits</code> 字节。在 32 位，最大可分配小于 <code>1 &lt;&lt; 32</code> 字节</li>
</ul>
</li>
</ul>
<h2 id="slice源码阅读"><a href="#slice源码阅读" class="headerlink" title="slice源码阅读"></a><strong>slice</strong>源码阅读</h2><ul>
<li>slice数据结构</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;  </span><br><span class="line"> <span class="comment">// Pointer 是指向一个数组的指针</span></span><br><span class="line"> array unsafe.Pointer  </span><br><span class="line"> <span class="comment">// len 代表当前切片的长度</span></span><br><span class="line"> <span class="built_in">len</span>   <span class="keyword">int</span>  </span><br><span class="line"> <span class="comment">// cap 是当前切片的容量</span></span><br><span class="line"> <span class="built_in">cap</span>   <span class="keyword">int</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h3><p>make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。</p>
<p>创建切片有两种形式，make 创建切片，空切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数传入需要初始化的切片的类型，长度以及容量，返回的指针会通过调用方组建成一个完成的slice结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断类型，和容量的乘积会不会超过可分配内存的大小，以及长度是否为0和容量是否小于长度</span></span><br><span class="line"> mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))  </span><br><span class="line"> <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;  </span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a  </span></span><br><span class="line">  <span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).  // &#x27;cap out of range&#x27; is true too, but since the cap is only being  // supplied implicitly, saying len is clearer.  // See golang.org/issue/4085.  mem, overflow := math.MulUintptr(et.size, uintptr(len))  </span></span><br><span class="line">  <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;  </span><br><span class="line">   panicmakeslicelen()  </span><br><span class="line">  &#125;  </span><br><span class="line">  panicmakeslicecap()  </span><br><span class="line"> &#125;  </span><br><span class="line">  <span class="comment">// 如果都正常，则调用此函数申请返回一个连续 切片中元素大小×切片容量 长度的内存空间的指针</span></span><br><span class="line"> <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nil和空切片"><a href="#nil和空切片" class="headerlink" title="nil和空切片"></a>nil和空切片</h3><p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p>
<h3 id="切片的扩容"><a href="#切片的扩容" class="headerlink" title="切片的扩容"></a>切片的扩容</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果需求的容量小于就容量则报错</span></span><br><span class="line">  <span class="comment">// 理论上来讲不应该出现这个问题</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// append 没法创建一个nil指针的但是len不为0的切片</span></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">  <span class="comment">// 如果需求容量大于双倍的旧容量那就直接使用需求容量</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前len小于1024则容量直接翻倍，否则按照1.25倍去递增直到满足需求容量</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// 在扩容时不能单单按照len来判断扩容所需要的内存长度</span></span><br><span class="line"><span class="comment">// 还要根据切片的元素类型去进行内存对齐</span></span><br><span class="line"><span class="comment">// 当元素的占用字节数为1，8 或者2的倍数时会进行内存对对齐</span></span><br><span class="line"><span class="comment">// 内存对齐策略按照向上取整方式进行</span></span><br><span class="line"><span class="comment">// 取整的目标时go内存分配策略中67个class分页中的大小进行取整</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line">	<span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">		<span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">			<span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">			shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">		&#125;</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		capmem = roundupsize(capmem)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所需要的内存超过了最大可分配内存则panic</span></span><br><span class="line">	<span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">  <span class="comment">// 如果当前元素类型不是指针，则会将超出切片当前长度的位置清空</span></span><br><span class="line">  <span class="comment">// 并在最后使用 将原数组内存中的内容拷贝到新申请的内存中。</span></span><br><span class="line">	<span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是指针会根据进行gc方面对其进行加以保护以免空指针在分配期间被gc回收</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem-et.size+et.ptrdata)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memmove(p, old.array, lenmem)</span><br><span class="line">	<span class="comment">//该函数最终会返回一个新的切片</span></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>  首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>  否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>  否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>  如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<p><del>如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。</del></p>
<p><del>一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。</del></p>
<p><strong>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</strong></p>
<p>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。</p>
<h3 id="切片的拷贝"><a href="#切片的拷贝" class="headerlink" title="切片的拷贝"></a>切片的拷贝</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="keyword">int</span>, fmPtr unsafe.Pointer, fmLen <span class="keyword">int</span>, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fmLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := fmLen</span><br><span class="line">	<span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">		n = toLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123;  </span><br><span class="line">    <span class="comment">// 如果就1个元素 直接赋值过去就好了</span></span><br><span class="line">		*(*<span class="keyword">byte</span>)(toPtr) = *(*<span class="keyword">byte</span>)(fmPtr)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接进行内存的拷贝，如果slice数据量过大将会影响性能</span></span><br><span class="line">		memmove(toPtr, fmPtr, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片的深拷贝和浅拷贝"><a href="#切片的深拷贝和浅拷贝" class="headerlink" title="切片的深拷贝和浅拷贝"></a>切片的深拷贝和浅拷贝</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; </span><br><span class="line">slice2 := slice1 </span><br><span class="line">fmt.Println(slice1) </span><br><span class="line">fmt.Println(slice2)</span><br><span class="line"><span class="comment">//同时改变两个数组 </span></span><br><span class="line">slice1[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(slice2,slice1)</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">fmt.Println(slice2)</span><br><span class="line">slice1[<span class="number">1</span>]=<span class="number">100</span>  <span class="comment">//只会影响slice1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>copy函数</strong><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The copy built-in function copies elements from a source slice into a  </span></span><br><span class="line"><span class="comment">// destination slice. (As a special case, it also will copy bytes from a  </span></span><br><span class="line"><span class="comment">// string to a slice of bytes.) The source and destination may overlap. Copy  </span></span><br><span class="line"><span class="comment">// returns the number of elements copied, which will be the minimum of  </span></span><br><span class="line"><span class="comment">// len(src) and len(dst).  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// ## 切片 dst 需要先初始化长度</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ## 源切片中元素类型为引用类型时，拷贝的是引用</span></span><br></pre></td></tr></table></figure></li>
<li>  如果 dst 长度小于 src 的长度，则 copy 部分；</li>
<li>  如果大于，则全部拷贝过来，只是没占满 dst 的坑位而已；</li>
<li>  相等时刚好不多不少 copy 过来。</li>
</ul>
]]></content>
      <categories>
        <category>语言学习</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并查集</title>
    <url>/2022/07/27/golang%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<hr>
<p>并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p>
<ul>
<li>  <strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li>
<li>  <strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。<br><a href="https://zhuanlan.zhihu.com/p/93647900">并查集-知乎</a></li>
</ul>
<span id="more"></span>
<!-- toc -->
<h2 id="并查集简介"><a href="#并查集简介" class="headerlink" title="并查集简介"></a>并查集简介</h2><p><strong>参考文章</strong></p>
<p>当然，这样的定义未免太过学术化，看完后恐怕不太能理解它具体有什么用。所以我们先来看看并查集最直接的一个应用场景：<strong>亲戚问题</strong>。</p>
<p>这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。</p>
<p><img src="/2022/07/27/golang%E5%B9%B6%E6%9F%A5%E9%9B%86/20220726164121.png" alt="并查集结构"></p>
<h2 id="并查集golang实现"><a href="#并查集golang实现" class="headerlink" title="并查集golang实现"></a>并查集golang实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">关系</span><br><span class="line">[2,3],[1,3],[4,2]</span><br><span class="line">输出：</span><br><span class="line">1（1组关系）</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> DisjointSet <span class="keyword">struct</span> &#123;  </span><br><span class="line">   fa     []<span class="keyword">int</span> <span class="comment">// 每个节点的父节点, 初始化成功时为自己  </span></span><br><span class="line">   height []<span class="keyword">int</span> <span class="comment">// 该节点的高度  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DisjointSet)</span> <span class="title">init</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   d.fa = <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)  </span><br><span class="line">   d.height = <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;  </span><br><span class="line">      d.fa[i] = i <span class="comment">// 表示自己为一个集合  </span></span><br><span class="line">      d.height[i] = <span class="number">1</span>  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 查找父节点  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DisjointSet)</span> <span class="title">find</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">   <span class="comment">// 父节点是自己则代表找到  </span></span><br><span class="line">   <span class="keyword">if</span> i == d.fa[i] &#123;  </span><br><span class="line">      <span class="keyword">return</span> i  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 递归查找  </span></span><br><span class="line">   d.fa[i] = d.find(d.fa[i])  </span><br><span class="line">   <span class="comment">// 优化路径(降低树的高度)  </span></span><br><span class="line">   <span class="keyword">return</span> d.fa[i]  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 合并两个集合  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DisjointSet)</span> <span class="title">merge</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="comment">// 这里有个优化, 谁合并谁, 矮的往高合并  </span></span><br><span class="line">   f1, f2 := d.find(i), d.find(j)  </span><br><span class="line">   h1, h2 := d.height[f1], d.height[f2]  </span><br><span class="line">   <span class="keyword">if</span> h1 &lt; h2 &#123;  </span><br><span class="line">      d.fa[f1] = f2  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      d.fa[f2] = f1  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">if</span> h1 == h2 &amp;&amp; f1 != f2 &#123;  </span><br><span class="line">      d.height[f1]++  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 计算集合个数  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DisjointSet)</span> <span class="title">count</span><span class="params">()</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(d.fa); i++ &#123;  </span><br><span class="line">      <span class="keyword">if</span> d.fa[i] == i &#123;  </span><br><span class="line">         res++  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> res  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   parent := <span class="built_in">new</span>(DisjointSet)  </span><br><span class="line">   parent.init(<span class="number">10</span>)  </span><br><span class="line">   parent.merge(<span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line">   parent.merge(<span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">   parent.merge(<span class="number">1</span>, <span class="number">3</span>)  </span><br><span class="line">   fmt.Println(parent.count())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
