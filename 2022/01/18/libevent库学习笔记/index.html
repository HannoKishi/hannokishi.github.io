<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/pawprint.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/pawprint.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/pawprint.png">
  <link rel="mask-icon" href="/images/pawprint.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hannokishi.link","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="libevent是一个C语言编写的轻量级的跨平台的高性能网络库，它基于事件驱动的Reactor模式，支持多种I&#x2F;O复用技术，目前已被广泛使用。了解其原理、研究其源码是非常有意义和价值的，本文首先介绍几种常见的I&#x2F;O模型，由此引出libevent并剖析其源码,希望能和读者一起提升网络相关的技能。">
<meta property="og:type" content="article">
<meta property="og:title" content="libevent库学习笔记">
<meta property="og:url" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="硝子の少年">
<meta property="og:description" content="libevent是一个C语言编写的轻量级的跨平台的高性能网络库，它基于事件驱动的Reactor模式，支持多种I&#x2F;O复用技术，目前已被广泛使用。了解其原理、研究其源码是非常有意义和价值的，本文首先介绍几种常见的I&#x2F;O模型，由此引出libevent并剖析其源码,希望能和读者一起提升网络相关的技能。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220107155339868.png">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110102301197.png">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110151551749.png">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110154957576.png">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110155617337.png">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110160543388.png">
<meta property="og:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110162619843.png">
<meta property="article:published_time" content="2022-01-17T16:21:16.000Z">
<meta property="article:modified_time" content="2022-01-17T16:21:16.000Z">
<meta property="article:author" content="Hannokishi">
<meta property="article:tag" content="Reactor">
<meta property="article:tag" content="libevent">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220107155339868.png">

<link rel="canonical" href="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>libevent库学习笔记 | 硝子の少年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">硝子の少年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">些細な話</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hannokishi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hannokishi">
      <meta itemprop="description" content="一切合切放り出したい">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="硝子の少年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          libevent库学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-17 16:21:16" itemprop="dateCreated datePublished" datetime="2022-01-17T16:21:16Z">2022-01-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">框架学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<p>libevent是一个C语言编写的轻量级的跨平台的高性能网络库，它基于事件驱动的Reactor模式，支持多种I/O复用技术，目前已被广泛使用。了解其原理、研究其源码是非常有意义和价值的，本文首先介绍几种常见的I/O模型，由此引出libevent并剖析其源码,希望能和读者一起提升网络相关的技能。</p>
<span id="more"></span>
<!-- toc -->
<p>[toc]</p>
<p><a target="_blank" rel="noopener" href="https://aceld.gitbooks.io/libevent/content/">参考文章</a></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪(也就是说输入已准备好，或者描述符已经承接更多的输出)，它就通知进程，这种能力称为I/O复用。IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。<code>多路是指网络连接，复用指的是同一个线程</code>。</p>
<h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为<code>内核空间</code>，一部分为<code>用户空间</code>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间，如图2所示。这里还有一个比较重要的概念，叫DMA（Direct Memory Access直接存储器访问），它的作用是处理各种I/O，包括网络I/O和磁盘I/O。CPU是不会直接处理I/O的，这是因为CPU非常宝贵，而I/O是比较耗时的，如果CPU一直等待某一次I/O事件完成，会带来极大的浪费，且性能会急剧下降，因此<code>需要一种机制能够完成I/O，并通知CPU，DMA即是这个角色。</code></p>
<img src="image-20220107155339868.png" alt="用户态和内核态" style="zoom: 25%;" />



<ol>
<li>等待数据准备</li>
<li>将数据从内核空间拷贝到进程中</li>
</ol>
<h3 id="Linux两大类网络模型"><a href="#Linux两大类网络模型" class="headerlink" title="Linux两大类网络模型"></a>Linux两大类网络模型</h3><ul>
<li>同步I/O</li>
</ul>
<blockquote>
<blockquote>
<p>阻塞I/O</p>
<p>非阻塞I/O</p>
<p>I/O多路复用</p>
<p>信号驱动I/O</p>
</blockquote>
</blockquote>
<ul>
<li>异步I/O</li>
</ul>
<p>同步I/O和异步I/O主要区别在于： 用户进程在发起I/O操作之后可以立刻去做其他事情，数据拷贝由硬件拷贝到内核空间、从内核空间拷贝到用户空间都不阻塞，这种就是异步I/O；两个步骤中有任何一步发生阻塞，就是同步I/O。</p>
<h2 id="I-O多路复用-1"><a href="#I-O多路复用-1" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set * readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  fd_set * writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数介绍</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nfds</td>
<td align="left">int</td>
<td align="left">文件描述符最大值+1</td>
</tr>
<tr>
<td align="left">readfds</td>
<td align="left">fd_set *</td>
<td align="left">读事件文件描述符集合</td>
</tr>
<tr>
<td align="left">writefds</td>
<td align="left">fd_set *</td>
<td align="left">写事件文件描述符集合</td>
</tr>
<tr>
<td align="left">exceptfds</td>
<td align="left">fd_set *</td>
<td align="left">异常事件文件描述符集合</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">timeval *</td>
<td align="left">超时时间，超过该时间即使没有事件到达，select也会返回，避免无休止地等待</td>
</tr>
</tbody></table>
</li>
<li><p>read事件代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">2000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  <span class="built_in">bind</span>(sockfd,(struct sockaddr*)&amp;addr ,<span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line">  <span class="built_in">listen</span> (sockfd, <span class="number">5</span>); </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (client));</span><br><span class="line">    addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">    fds[i] = <span class="built_in">accept</span>(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">    	max = fds[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ####################################################################</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;rset);     <span class="comment">// 1. 初始化/重置rset</span></span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  		<span class="built_in">FD_SET</span>(fds[i],&amp;rset); <span class="comment">// 2. 为rset赋值</span></span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 传入最大描述符数量加1</span></span><br><span class="line">	<span class="built_in">select</span>(max+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 3. select阻塞</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fds[i], &amp;rset))&#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(fds[i], buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>select 底层机制<br>内核会将传入的rset由用户态拷贝到内核态，然后在内核中判断每一个置位的rset是否有数据到达（将rset拷贝到内核态是因为在内核中判断是否有数据到达比在用户态判断效率高很多），如果有，则标记这一位，如果没有，继续往后判断，除非到达select的超时时间，所以select是一个阻塞的函数。select函数中第一个参数nfds有什么用呢？select在对rset遍历时，会截取0~nfds，因为大于nfds是不会有文件描述符的；当select函数返回时，循环遍历这5个文件描述符，然后检测每一个文件描述符是否被标记，如果标记了，说明有read事件发生，则读取缓存中的数据。这里需要注意某一个文件描述符是否有数据是随机的，可能有多个文件描述符同时有数据到达，因此需要执行for遍历每一个文件描述符。</p>
</li>
</ul>
<ul>
<li>select存在的问题</li>
</ul>
<ol>
<li>len(rset)=1024,所以最多只能监听1024个文件描述符。这个是操作系统进行的限制，虽然可以更改，但是有上限；</li>
<li>rset不可重用。从代码中可以看到，每次循环时，都需要调用FD_ZERO(&amp;rest)，重置rset，这是因为内核检测是否有数据时会更改rset，如果不重置，上一次select返回的结果会对下一次内核判断某一个文件描述符是否有数据产生影响；</li>
<li>解除select阻塞后需遍历每一个fd。这是因为内核判断是否有数据后会直接返回，但是并没有返回究竟是哪一个文件描述符有数据。</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line">      <span class="keyword">short</span> events;  <span class="comment">// 用户感兴趣的事件</span></span><br><span class="line">      <span class="keyword">short</span> revents; <span class="comment">// 系统触发的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>参数介绍</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fds</td>
<td align="left">pollfd *</td>
<td align="left">文件描述符数组，和select不同，fds中每一个元素不是一个数字，而是pollfd类型</td>
</tr>
<tr>
<td align="left">nfds</td>
<td align="left">unsigned int</td>
<td align="left">监听的文件描述符数量</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">int</td>
<td align="left">超时时间，含义和select中timeout类似</td>
</tr>
</tbody></table>
</li>
<li><p>poll使用代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (client));</span><br><span class="line">    addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">    pollfds[i].fd = <span class="built_in">accept</span>(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// ######################################################################</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">poll</span>(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">			pollfds[i].revents = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(pollfds[i].fd, buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>poll原理<br>poll的原理和select非常类似，也是将pollfds拷贝到内核空间。不同的是，当内核判断某个pollfd有数据时，会将pollfd.revents置位，然后解除poll的阻塞。因此，<code>for中遍历每一个pollfd先检测该文件描述符是否被置位</code>，如果是说明有数据，则将置位的revents恢复成默认，随后读取该数据。</p>
</li>
<li><p>poll存在的问题<br>poll解决了select中rset无法重用的问题，通过自定义的pollfd结构，巧妙地完成了”置位-恢复”的操作；而且，poll中文件描述符不是一个数字而是pollfd结构，可以监听更多的文件描述符，也就<code>突破了select中len(rst)=1024的限制</code>，<br>但是也存在一个问题：poll解除阻塞后依旧需要循环遍历所有的pollfds，然后才知道具体哪一个文件描述符有数据</p>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll在poll的基础上，通过双向链表的结构，解决了poll中存在的问题，接下来看epoll的具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[4];</span></span><br><span class="line">  <span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (client));</span><br><span class="line">    addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">    ev.data.fd = <span class="built_in">accept</span>(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ###################################</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">  	nfds = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">4</span>, <span class="number">10000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(events[i].data.fd, buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>epoll的三个主要函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>); <span class="comment">// 这里的参数10没有什么意义，事实上，通过源码可以知道这里只要传入一个正数就OK</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line">nfds = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">4</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三个函数对应的步骤:</p>
</blockquote>
</li>
</ul>
<ol>
<li>生成epoll面板epfd（epoll_create函数的功能，对应图5中的橙黄色部分）</li>
<li>在 epfd中将文件描述符和事件绑定（epoll_ctl函数的功能，对应图中的fd[x]–&gt;events）</li>
<li>阻塞并监听文件描述符（epoll_wait函数的功能）</li>
</ol>
<img src="image-20220110102301197.png" alt="" style="zoom:60%;"  />


<p>内核空间部分是如何处理的，当某一个文件描述符有数据到达时，内核空间会将该文件描述符调整到最前面，且nfds+1，对应图中绿色部分，表示fd3和fd2有数据，此时nfds=2，解除epoll_wait函数的阻塞并返回nfds的值。在for进行遍历时，只需要遍历0~nfds即可，也就解决了select和poll中需要遍历整个文件描述符数组的问题。</p>
<ul>
<li>epoll的触发机制</li>
</ul>
<ol>
<li>边缘触发（edge triggered ET）<blockquote>
<p>对于边缘触发，<code>epoll_wait()只返回一次</code>，即只在该读写事件发生时返回，也就是说如果事件处理函数只读取了该文件描述缓冲区的部分内容时返回，再次调用epoll_wait()，虽然此时该描述符对应缓冲区中还有数据，但epoll_wait()函数不会返回。</p>
</blockquote>
</li>
<li>水平触发（level triggered LT）<blockquote>
<p>对于水平触发，它不管是否有事件反生，只要文件描述符对应的缓冲区中有数据可读写，epoll_wait()就会返回。</p>
</blockquote>
</li>
</ol>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>本节将介绍Reactor模式，它是libevent的核心，因此有必要对其进行介绍，有了上文中select、poll、epoll的基础，Reactor模式就比较好理解了。 Reactor释义”反应堆”（中文翻译的名称和它的功能几乎没有什么联系，因此下文还是采用英文名），Reactor模式的是一种基于事件驱动的异步回调机制。一般的函数调用是压栈式调用，函数之间调用需要同步等待，而Reactor模式不同，应用程序提供相应的接口并注册到Reactor上，<code>如果相应的事件发生，Reactor将主动调用应用程序注册的接口（也就是回调函数）</code>。所以，上文中的select、poll、epoll其实都是Reactor模式。</p>
<img src="image-20220110151551749.png" alt="" style="zoom:50%;" />

<ul>
<li>代码框架<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">register_handler</span><span class="params">(Event_Handler *pHandler, <span class="keyword">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove_handler</span><span class="params">(Event_Handler *pHeadler, <span class="keyword">int</span> event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(timeval *ptv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event_Handler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// events maybe read/write/tiomeout .etc</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> events)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HANDLE <span class="title">get_handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Reactor组件</li>
</ul>
<ol>
<li>事件源(图中的handle)<blockquote>
<p>在linux系统中是文件描述符，在window上是socket或Handle，下文统称为”句柄”</p>
</blockquote>
</li>
<li>事件多路分发机制(图中的Event Demultiplexer)<blockquote>
<p>由操作系统提供的I/O多路分发机制，比如上文所述的select、poll、epoll</p>
</blockquote>
</li>
<li>反应器(图中的Reactor)<blockquote>
<p>Reactor模式中的事件管理接口，提供注册、注销事件和事件循环，它的声明参见代码中的class Reactor</p>
</blockquote>
</li>
<li>事件处理程序(图中的Event_Handler和Concrete_Event_Handler)<blockquote>
<p>包括抽象处理程序和具体处理程序，主要是考虑扩展性，它的声明参见class Event_Handler</p>
</blockquote>
</li>
</ol>
<h2 id="Libevent"><a href="#Libevent" class="headerlink" title="Libevent"></a>Libevent</h2><h3 id="libevent定时器实现"><a href="#libevent定时器实现" class="headerlink" title="libevent定时器实现"></a>libevent定时器实现</h3><ul>
<li>代码实例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time_cb</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timer wakeup\n&quot;</span>);</span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv); <span class="comment">// reschedule timer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化libevent,相当于初始化Reactor实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> <span class="built_in">event_init</span>();</span><br><span class="line">    tv.tv_sec = <span class="number">10</span>; <span class="comment">// 10s period</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define evtimer_set(ev, cb, arg)	event_set(ev, -1, 0, cb, arg)</span></span><br><span class="line">    <span class="comment">// evtimer_set 也是event_set</span></span><br><span class="line">    <span class="comment">// 2. 初始化时间event,设置回调函数和关注的事件</span></span><br><span class="line">    <span class="built_in">evtimer_set</span>(&amp;ev, time_cb, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置event从属的event_base</span></span><br><span class="line">    <span class="built_in">event_base_set</span>(base, &amp;ev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 正式添加事件</span></span><br><span class="line">    <span class="built_in">event_add</span>(&amp;ev, &amp;tv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 等待事件就绪,阻塞</span></span><br><span class="line">    <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="libevent源码分析"><a href="#libevent源码分析" class="headerlink" title="libevent源码分析"></a>libevent源码分析</h3><p>事件event结构</p>
<img src="image-20220110154957576.png" alt="" style="zoom:40%;" />
- 双向链表事件（使用双向链表结构保存了event的所有事件）
-- event_next（保存所有已注册的I/O事件）
-- ev_signal_next（保存所有已注册的信号事件）
-- ev_active_next（保存所有已激活的事件，激活的含义就是文件描述符有数据）
- ev_base（该事件所属的Reactor实例，是一个event_base的指针，关于event_base，后面将详细介绍）
- ev_events（它是event关注的事件类型，有多种取值，且可以"|"组合，比如"EV_ERAD|EV_PERSIST",当然，定时器事件不能和I/O事件组合在一起，可以考虑下这是为什么）

<img src="image-20220110155617337.png" alt="" style="zoom:50%;" />
libevent事件管理的结构，左侧红色部分表示I/O事件和signal的结构，它们都是由若干事件组成的双向链表，图中把它们画在一起是因为它们结构相同，但实际上它们是两个双向链表；中间蓝色部分表示时间事件，时间事件在底层是一个以超时时间为key的小根堆，由于libevent需要频繁获取最近的时间事件，因此采用小根堆存储，小根堆在底层是用数组实现的；右边绿色部分表示激活事件的结构，它的底层也是双向链表，但它与I/O事件的双向链表不同，它是根据事件的priority进行排序的，优先级高的在前面，优先被执行。因此，有可能出现优先级比较低的事件一直得不到执行。libevent提供了设置事件优先级的api，如果不设置，会给一个默认的优先级。



<h3 id="事件接口函数"><a href="#事件接口函数" class="headerlink" title="事件接口函数"></a>事件接口函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件设置接口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> fd, <span class="keyword">short</span> events,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> (*callback)(<span class="keyword">int</span>,<span class="keyword">short</span>,<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// fd:事件ev绑定的文件描述符或信号,如果是超时事件,fd=-1</span></span></span><br><span class="line"><span class="function"><span class="comment">// events:设置事件的类型 EV_READ|EV_PERSIST, EV_WRITE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_set</span><span class="params">(struct event_base *base, struct event *ev)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置event的ev到event_base上</span></span></span><br><span class="line"><span class="function"><span class="comment">// libevent 有一个全局的event_base指针,</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用该函数可以将ev注册到自定义的event_base上</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> pri)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置ev的优先级</span></span></span><br></pre></td></tr></table></figure>

<h3 id="事件处理框架"><a href="#事件处理框架" class="headerlink" title="事件处理框架"></a>事件处理框架</h3><ul>
<li>event_base框架</li>
</ul>
<img src="image-20220110160543388.png" alt="" style="zoom:20%;" />
- 核心变量
> 核心变量包括evsel和evbase。添加事件的调用关系为evsel->add(evbase, ev)，evsel只负责调用，将具体的事件ev注册到evbase中。
- 事件指针
> 主要包括activequeues和event_queue，分别保存带有优先级的激活事件和所有注册时间的event指针。activequeues[priority]是一个链表，链表中的每个节点指向一个优先级为priority的激活事件event。
- 时间管理变量
> 包括时间缓存tv_cache和event_tv，下文会继续介绍
- 其他变量
> 主要是各个结构数量的统计变量，比如event_count是注册事件的总和，nactivequeues是激活事件的总量。

<h3 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h3><p>libevent提供的对于事件的注册、注销以及当事件处于激活状态时调用回到接口的api如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> loops)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *event, <span class="keyword">int</span> res, <span class="keyword">short</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>event_add 函数介绍:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ev:指向要注册的事件;tv:超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> ev-&gt;base;</span><br><span class="line">    <span class="comment">// event_base使用的系统IO策略</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> =</span> base-&gt;evsel; </span><br><span class="line">    <span class="keyword">void</span> *evbase = base-&gt;evbase;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新的timer事件，在小根堆上预留一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (tv != <span class="literal">NULL</span> &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min_heap_reserve</span>(&amp;base-&gt;timeheap,</span><br><span class="line">			<span class="number">1</span> + <span class="built_in">min_heap_size</span>(&amp;base-&gt;timeheap)) == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> (<span class="number">-1</span>);  <span class="comment">/* ENOMEM == errno */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_SIGNAL)) &amp;&amp;</span><br><span class="line">	    !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE))) &#123;</span><br><span class="line">		res = evsel-&gt;<span class="built_in">add</span>(evbase, ev);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="comment">// 如果事件添加成功则插入到eventqueue中</span></span><br><span class="line">			<span class="built_in">event_queue_insert</span>(base, ev, EVLIST_INSERTED);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; tv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">		<span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT) <span class="comment">// EVLIST_TIMEOUT表示该事件已经存在与定时器堆中，则删除旧的</span></span><br><span class="line">			<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">			</span><br><span class="line">        <span class="built_in">gettime</span>(base, &amp;now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;</span><br><span class="line">		    (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123; <span class="comment">// 如果事件已经就绪则从激活链表中删除</span></span><br><span class="line">			<span class="built_in">event_queue_remove</span>(base, ev, EVLIST_ACTIVE);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 插入定时器事件</span></span><br><span class="line">        <span class="built_in">event_queue_insert</span>(base, ev, EVLIST_TIMEOUT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环是libevent非常重要的一部分，它的主要职责就是阻塞等待事件到来并调用事件绑定的回到函数。</p>
<ul>
<li>事件循环的逻辑结构</li>
</ul>
<img src="image-20220110162619843.png" alt="" style="zoom:26%;" />
* 事件循环实现
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> =</span> base-&gt;evsel;</span><br><span class="line"><span class="keyword">void</span> *evbase = base-&gt;evbase;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line"><span class="keyword">int</span> res, done;</span><br><span class="line"><span class="comment">// 清空时间缓存</span></span><br><span class="line">base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例</span></span><br><span class="line"><span class="keyword">if</span> (base-&gt;sig.ev_signal_added)</span><br><span class="line">	evsignal_base = base;</span><br><span class="line">done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!done) &#123; <span class="comment">// 事件主循环</span></span><br><span class="line">	<span class="comment">// 校正系统时间</span></span><br><span class="line">	<span class="built_in">timeout_correct</span>(base, &amp;tv);</span><br><span class="line">	<span class="comment">// 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间</span></span><br><span class="line">	tv_p = &amp;tv;</span><br><span class="line">	<span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class="line">		<span class="built_in">timeout_next</span>(base, &amp;tv_p);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 依然有未处理的就绪时间，就让I/O demultiplexer立即返回，不必等待</span></span><br><span class="line">			<span class="comment">// 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理</span></span><br><span class="line">			<span class="built_in">evutil_timerclear</span>(&amp;tv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前没有注册事件，就退出</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">event_haveevents</span>(base)) &#123;</span><br><span class="line">		<span class="built_in">event_debug</span>((<span class="string">&quot;%s: no events registered.&quot;</span>, __func__));</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新last wait time，并清空time cache</span></span><br><span class="line">	<span class="built_in">gettime</span>(base, &amp;base-&gt;event_tv);</span><br><span class="line">	base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；</span></span><br><span class="line">	<span class="comment">// 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中</span></span><br><span class="line">	res = evsel-&gt;<span class="built_in">dispatch</span>(base, evbase, tv_p);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 将time cache赋值为当前系统时间</span></span><br><span class="line">	<span class="built_in">gettime</span>(base, &amp;base-&gt;tv_cache);</span><br><span class="line">	<span class="comment">// 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中</span></span><br><span class="line">	<span class="built_in">timeout_process</span>(base);</span><br><span class="line">	<span class="comment">// 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理</span></span><br><span class="line">	<span class="comment">// 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，</span></span><br><span class="line">	<span class="comment">// 然后处理链表中的所有就绪事件；</span></span><br><span class="line">	<span class="comment">// 因此低优先级的就绪事件可能得不到及时处理；</span></span><br><span class="line">	<span class="keyword">if</span> (base-&gt;event_count_active) &#123;</span><br><span class="line">		<span class="built_in">event_process_active</span>(base);</span><br><span class="line">		<span class="keyword">if</span> (!base-&gt;event_count_active &amp;&amp; (flags &amp; EVLOOP_ONCE))</span><br><span class="line">			done = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; EVLOOP_NONBLOCK)</span><br><span class="line">		done = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束，清空时间缓存</span></span><br><span class="line">base-&gt;tv_cache.tv_sec = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">event_debug</span>((<span class="string">&quot;%s: asked to terminate loop.&quot;</span>, __func__));</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>libevent函数的一大亮点就是将I/O和timer事件统一起来了，这里就有个疑问，为什么将IO事件的timeout设置为所有定时器事件的最小时间，就能将timer事件完美融合到系统IO机制中？原因是timer事件主要目标是定时器到期后需要触发一个回调，IO机制是已经激活的event才会触发回调函数，所以，只要有一种机制可以将到期的timer放到激活链表中就可以。libevent将IO事件的timeout设置为定时器事件的最小时间，那么当IO事件激活时，从timer堆中取出最小的timer判断是否到期，如果到期将其也放入激活链表中；如果IO时间在timeout内没有激活,则会触发超时，此时也检查最小的timer是否到期，这样就能将timer事件很好地放到激活事件中。也就实现了将I/O和timer事件统一起来。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Hannokishi
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://hannokishi.link/2022/01/18/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="libevent库学习笔记">https://hannokishi.link/2022/01/18/libevent库学习笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reactor/" rel="tag"># Reactor</a>
              <a href="/tags/libevent/" rel="tag"># libevent</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/17/docker%E4%B8%8B%E6%90%AD%E5%BB%BAwordpress%E7%AB%99%E7%82%B9/" rel="prev" title="docker下搭建wordpress站点">
      <i class="fa fa-chevron-left"></i> docker下搭建wordpress站点
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/19/Libgo%E5%8D%8F%E7%A8%8B%E5%BA%93/" rel="next" title="Libgo协程库">
      Libgo协程库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">I&#x2F;O多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.</span> <span class="nav-text">用户空间和内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E4%B8%A4%E5%A4%A7%E7%B1%BB%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">Linux两大类网络模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1"><span class="nav-number">2.</span> <span class="nav-text">I&#x2F;O多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">2.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">2.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">2.3.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">Reactor模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Libevent"><span class="nav-number">4.</span> <span class="nav-text">Libevent</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libevent%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">libevent定时器实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.2.</span> <span class="nav-text">libevent源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">事件接口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6"><span class="nav-number">4.4.</span> <span class="nav-text">事件处理框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">接口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.6.</span> <span class="nav-text">事件循环</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hannokishi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hannokishi</p>
  <div class="site-description" itemprop="description">一切合切放り出したい</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hannokishi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hannokishi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huangenming1996@gmail.com" title="E-Mail → mailto:huangenming1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

      <!--网易云播放器-->
      <div id="music163player">
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=1331357732&auto=1&height=66">
          </iframe>
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hannokishi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
